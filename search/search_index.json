{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Witnet ecosystem! \u00b6 The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information in behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central for incentivizing the network players to abide by the protocol and make them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum . Node operators, a.k.a. Witnesses \u00b6 The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts. Developers \u00b6 The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet . Contribute to Witnet-Rust or Sheikah . Witnet Foundation \u00b6 Witnet Foundation is the independent entity currently in charge of funding the development of Witnet-Rust and Sheikah, as well as fostering the thriving ecosystem around the Witnet protocol. Other stakeholders \u00b6 The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many things you can do to spread the word!","title":"Ecosystem"},{"location":"#welcome-to-the-witnet-ecosystem","text":"The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information in behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central for incentivizing the network players to abide by the protocol and make them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum .","title":"Welcome to the Witnet ecosystem!"},{"location":"#node-operators-aka-witnesses","text":"The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts.","title":"Node operators, a.k.a. Witnesses"},{"location":"#developers","text":"The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet . Contribute to Witnet-Rust or Sheikah .","title":"Developers"},{"location":"#witnet-foundation","text":"Witnet Foundation is the independent entity currently in charge of funding the development of Witnet-Rust and Sheikah, as well as fostering the thriving ecosystem around the Witnet protocol.","title":"Witnet Foundation"},{"location":"#other-stakeholders","text":"The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many things you can do to spread the word!","title":"Other stakeholders"},{"location":"community/contributing/","text":"Contributing to Witnet \u00b6 Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document. Code of conduct \u00b6 Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well. I just have a question \u00b6 Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response. How can I contribute? \u00b6 Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma. Reporting bugs \u00b6 This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having. How do I submit a good bug report? \u00b6 Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version? Suggesting enhancements \u00b6 This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible. How Do I Submit A Good Enhancement Suggestion? \u00b6 Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package. Your First Code Contribution \u00b6 Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two. Sending a Pull Request \u00b6 Commit messages convention \u00b6 We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat(mining): use a random nonce as input in mint transactions BREAKING CHANGE: former mint transactions containing no inputs will be rendered invalid refactor(config): make `config` actor return settings as `Option`s docs : add RADON ` FLOAT_TOSTRING ` opcode this operator converts any floating point number into a UTF8 string chore(cargo): upgrade `actix` to version 0.8.1 fix #503 PGP-signing your commits \u00b6 All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"Contributing"},{"location":"community/contributing/#contributing-to-witnet","text":"Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document.","title":"Contributing to Witnet"},{"location":"community/contributing/#code-of-conduct","text":"Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well.","title":"Code of conduct"},{"location":"community/contributing/#i-just-have-a-question","text":"Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response.","title":"I just have a question"},{"location":"community/contributing/#how-can-i-contribute","text":"Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma.","title":"How can I contribute?"},{"location":"community/contributing/#reporting-bugs","text":"This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having.","title":"Reporting bugs"},{"location":"community/contributing/#how-do-i-submit-a-good-bug-report","text":"Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version?","title":"How do I submit a good bug report?"},{"location":"community/contributing/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible.","title":"Suggesting enhancements"},{"location":"community/contributing/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package.","title":"How Do I Submit A Good Enhancement Suggestion?"},{"location":"community/contributing/#your-first-code-contribution","text":"Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two.","title":"Your First Code Contribution"},{"location":"community/contributing/#sending-a-pull-request","text":"","title":"Sending a Pull Request"},{"location":"community/contributing/#commit-messages-convention","text":"We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat(mining): use a random nonce as input in mint transactions BREAKING CHANGE: former mint transactions containing no inputs will be rendered invalid refactor(config): make `config` actor return settings as `Option`s docs : add RADON ` FLOAT_TOSTRING ` opcode this operator converts any floating point number into a UTF8 string chore(cargo): upgrade `actix` to version 0.8.1 fix #503","title":"Commit messages convention"},{"location":"community/contributing/#pgp-signing-your-commits","text":"All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"PGP-signing your commits"},{"location":"community/roadmap/","text":"Community Roadmap \u00b6 Witnet is an open initiative and Witnet-Rust and Sheikah are open source projects that are under development by an open community of organizations and independent developers. This means that no one can set the roadmap unilaterally. During the pre-mainnet phase, a subsequent testnet release is expected every to months, and each of them is a hard fork and full reset of the chain: [ Testnet-1 ] Jan 2019: basic protocol capabilities [ Testnet-2 ] Mar 2019: security and scalability improvements [ Testnet-3 ] May 2019: algorithmic reputation system [ Testnet-4 ] Jul 2019: Ethereum bridge [ Testnet-5 ] Sep 2019: mainnet readiness Given the experimental nature of the technologies and network protocols under development, these dates and deliverables may be subject to change due to reasons beyond the control of Witnet Foundation.","title":"Roadmap"},{"location":"community/roadmap/#community-roadmap","text":"Witnet is an open initiative and Witnet-Rust and Sheikah are open source projects that are under development by an open community of organizations and independent developers. This means that no one can set the roadmap unilaterally. During the pre-mainnet phase, a subsequent testnet release is expected every to months, and each of them is a hard fork and full reset of the chain: [ Testnet-1 ] Jan 2019: basic protocol capabilities [ Testnet-2 ] Mar 2019: security and scalability improvements [ Testnet-3 ] May 2019: algorithmic reputation system [ Testnet-4 ] Jul 2019: Ethereum bridge [ Testnet-5 ] Sep 2019: mainnet readiness Given the experimental nature of the technologies and network protocols under development, these dates and deliverables may be subject to change due to reasons beyond the control of Witnet Foundation.","title":"Community Roadmap"},{"location":"node-operators/cli/","text":"Command Line Interface (CLI) \u00b6 The cli subcommand provides a human-friendly command-line interface to the node JSON-RPC API . Usage \u00b6 See all the available options by running the help command. cargo run -- can be used to replace witnet in a development environment. witnet node --help cargo run -- node --help To get more information about a particular command: witnet node blockchain --help The JSON-RPC server address is obtained from the configuration file . The path of this file can be set using the -c or --config flag. This flag must appear before node . witnet -c witnet.toml node blockchain You can use the -n flag to easily overwrite the node address. This flag must appear after the command name. witnet node blockchain -n \"127.0.0.1:1234\" If there is any error, the process will return a non-zero exit code. witnet node blockchain Error: Connection refused (os error 111) The executable implements the usual logging API, which can be enabled using RUST_LOG=witnet=debug : $ RUST_LOG=witnet=debug witnet cli getBlockChain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Commands \u00b6 block \u00b6 Find a block by its hash. witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 The hash of the block should be provided as a hexadecimal string. { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"block_header\" :{ \"beacon\" :{ \"checkpoint\" : 74005 , \"hashPrevBlock\" : \"ac6ec0020e726577fa3df3fd04de2a30b020c4a864602375a129e090707a90dc\" }, \"merkle_roots\" :{ \"commit_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"dr_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"mint_hash\" : \"a02e6038ec2a472d6daa8f374bdeca84a62cd5731d33dd865f497f34360874ef\" , \"reveal_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"tally_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"vt_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" }, \"proof\" :{ \"proof\" :{ \"proof\" :[ 2 , 76 , 213 , 68 , 242 , 86 , 29 , 133 , 44 , 102 , 231 , 220 , 74 , 198 , 196 , 117 , 106 , 87 , 200 , 168 , 77 , 176 , 129 , 130 , 10 , 164 , 24 , 13 , 131 , 141 , 240 , 28 , 46 , 72 , 247 , 80 , 196 , 178 , 67 , 144 , 46 , 246 , 44 , 191 , 20 , 119 , 187 , 160 , 110 , 73 , 60 , 243 , 160 , 231 , 188 , 124 , 69 , 238 , 130 , 148 , 69 , 137 , 102 , 60 , 56 , 33 , 62 , 127 , 90 , 62 , 47 , 62 , 77 , 79 , 163 , 151 , 49 , 233 , 127 , 65 , 103 ], \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }}}, \"version\" : 0 }, \"block_sig\" :{ \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 13 , 144 , 153 , 43 , 104 , 8 , 14 , 205 , 157 , 88 , 181 , 226 , 110 , 189 , 101 , 148 , 248 , 193 , 170 , 99 , 177 , 219 , 228 , 149 , 239 , 34 , 1 , 245 , 13 , 207 , 123 , 220 , 2 , 32 , 108 , 71 , 130 , 109 , 147 , 73 , 92 , 96 , 149 , 102 , 125 , 144 , 146 , 252 , 143 , 66 , 74 , 105 , 52 , 185 , 196 , 217 , 95 , 249 , 157 , 11 , 108 , 254 , 35 , 187 , 67 , 12 ]}}}, \"txns\" :{ \"commit_txns\" :[], \"data_request_txns\" :[], \"mint\" :{ \"epoch\" : 74005 , \"output\" :{ \"pkh\" : \"twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr\" , \"time_lock\" : 0 , \"value\" : 50000000000 }}, \"reveal_txns\" :[], \"tally_txns\" :[], \"value_transfer_txns\" :[]}}, \"id\" : \"1\" } blockchain \u00b6 List block hashes. witnet node blockchain This method accepts two optional arguments. --epoch=n : the first epoch for which to show block hashes. A negative epoch means \"n epochs ago\". --limit=n : the number of epochs. If zero, unlimited. # Get all the block hashes from the genesis block witnet node blockchain --epoch = 0 --limit = 0 # Get the block hashes from epochs [0, 19] witnet node blockchain --epoch = 0 --limit = 20 # Get the block hashes from the last 10 epochs witnet node blockchain --epoch = -10 --limit = 0 # Get the block hash from 10 epochs ago witnet node blockchain --epoch = -10 --limit = 1 # Get the block hash from the last block witnet node blockchain --epoch = -1 --limit = 1 Example output: block for epoch #76229 had digest 8dd75bb0d5475a93c27c4166677fbb3bc154e6731c7e07ecad549a58851c84a4 getBalance \u00b6 Get total balance of the given account. --pkh=address : Public key hash for which to get balance. If omitted, defaults to the node pkh. witnet node getBalance witnet node getBalance --pkh = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: 34099999950005 getPkh \u00b6 Get the public key hash of the node. This is the address used for mining blocks, resolving data requests, and receiving value transfer transactions. witnet node getPkh Example output: twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr getReputation \u00b6 Get the reputation of the given account. --pkh=address : Public key hash for which to get balance. If omitted, defaults to the node pkh. witnet node getReputation witnet node getReputation --pkh = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: Identity twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr has 1 reputation and is active witnet node getReputation --all Example output: Total Reputation: { [A] twit1t99a5r6d0lqstl8rdkqw3ywfs2y4zwqhy5zprt: 1 [A] twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr: 1 } raw \u00b6 The raw command allows sending raw JSON-RPC requests from the command line. It can be used in an interactive way: each line of user input will be sent to the JSON-RPC server without any modifications: $ witnet -c witnet.toml node raw Each block represents a method call: the first line is a request, the second line is a response. hi { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } { \"jsonrpc\" : \"2.0\" , \"method\" : \"getBlockChain\" , \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"result\" : [[ 242037 , \"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\" ]], \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"method\" : \"someInvalidMethod\" , \"id\" : 2 } { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32601 , \"message\" : \"Method not found\" }, \"id\" : 2 } bye { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } Alternatively, the input can be read from a file using pipes, as is usual in Unix-like environments: $ cat get_block_chain.txt | witnet node raw {\"jsonrpc\":\"2.0\",\"result\":[[242037,\"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\"]],\"id\":1} send \u00b6 Create a value transfer transaction. --pkh=address : public key hash of the destination. --value=amount : value --fee=fee : fee --time-lock=timestamp : optional time lock for the created output: the receiver will not be able to spend the output until the timestamp is reached. 0 means no time-lock. On success, returns the transaction hash: witnet node send --pkh=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} On error, returns the error message: witnet node send --pkh = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Example with time lock set to 2019-10-01 witnet node send --pkh=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"}","title":"Command Line Interface"},{"location":"node-operators/cli/#command-line-interface-cli","text":"The cli subcommand provides a human-friendly command-line interface to the node JSON-RPC API .","title":"Command Line Interface (CLI)"},{"location":"node-operators/cli/#usage","text":"See all the available options by running the help command. cargo run -- can be used to replace witnet in a development environment. witnet node --help cargo run -- node --help To get more information about a particular command: witnet node blockchain --help The JSON-RPC server address is obtained from the configuration file . The path of this file can be set using the -c or --config flag. This flag must appear before node . witnet -c witnet.toml node blockchain You can use the -n flag to easily overwrite the node address. This flag must appear after the command name. witnet node blockchain -n \"127.0.0.1:1234\" If there is any error, the process will return a non-zero exit code. witnet node blockchain Error: Connection refused (os error 111) The executable implements the usual logging API, which can be enabled using RUST_LOG=witnet=debug : $ RUST_LOG=witnet=debug witnet cli getBlockChain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111)","title":"Usage"},{"location":"node-operators/cli/#commands","text":"","title":"Commands"},{"location":"node-operators/cli/#block","text":"Find a block by its hash. witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 The hash of the block should be provided as a hexadecimal string. { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"block_header\" :{ \"beacon\" :{ \"checkpoint\" : 74005 , \"hashPrevBlock\" : \"ac6ec0020e726577fa3df3fd04de2a30b020c4a864602375a129e090707a90dc\" }, \"merkle_roots\" :{ \"commit_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"dr_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"mint_hash\" : \"a02e6038ec2a472d6daa8f374bdeca84a62cd5731d33dd865f497f34360874ef\" , \"reveal_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"tally_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"vt_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" }, \"proof\" :{ \"proof\" :{ \"proof\" :[ 2 , 76 , 213 , 68 , 242 , 86 , 29 , 133 , 44 , 102 , 231 , 220 , 74 , 198 , 196 , 117 , 106 , 87 , 200 , 168 , 77 , 176 , 129 , 130 , 10 , 164 , 24 , 13 , 131 , 141 , 240 , 28 , 46 , 72 , 247 , 80 , 196 , 178 , 67 , 144 , 46 , 246 , 44 , 191 , 20 , 119 , 187 , 160 , 110 , 73 , 60 , 243 , 160 , 231 , 188 , 124 , 69 , 238 , 130 , 148 , 69 , 137 , 102 , 60 , 56 , 33 , 62 , 127 , 90 , 62 , 47 , 62 , 77 , 79 , 163 , 151 , 49 , 233 , 127 , 65 , 103 ], \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }}}, \"version\" : 0 }, \"block_sig\" :{ \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 13 , 144 , 153 , 43 , 104 , 8 , 14 , 205 , 157 , 88 , 181 , 226 , 110 , 189 , 101 , 148 , 248 , 193 , 170 , 99 , 177 , 219 , 228 , 149 , 239 , 34 , 1 , 245 , 13 , 207 , 123 , 220 , 2 , 32 , 108 , 71 , 130 , 109 , 147 , 73 , 92 , 96 , 149 , 102 , 125 , 144 , 146 , 252 , 143 , 66 , 74 , 105 , 52 , 185 , 196 , 217 , 95 , 249 , 157 , 11 , 108 , 254 , 35 , 187 , 67 , 12 ]}}}, \"txns\" :{ \"commit_txns\" :[], \"data_request_txns\" :[], \"mint\" :{ \"epoch\" : 74005 , \"output\" :{ \"pkh\" : \"twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr\" , \"time_lock\" : 0 , \"value\" : 50000000000 }}, \"reveal_txns\" :[], \"tally_txns\" :[], \"value_transfer_txns\" :[]}}, \"id\" : \"1\" }","title":"block"},{"location":"node-operators/cli/#blockchain","text":"List block hashes. witnet node blockchain This method accepts two optional arguments. --epoch=n : the first epoch for which to show block hashes. A negative epoch means \"n epochs ago\". --limit=n : the number of epochs. If zero, unlimited. # Get all the block hashes from the genesis block witnet node blockchain --epoch = 0 --limit = 0 # Get the block hashes from epochs [0, 19] witnet node blockchain --epoch = 0 --limit = 20 # Get the block hashes from the last 10 epochs witnet node blockchain --epoch = -10 --limit = 0 # Get the block hash from 10 epochs ago witnet node blockchain --epoch = -10 --limit = 1 # Get the block hash from the last block witnet node blockchain --epoch = -1 --limit = 1 Example output: block for epoch #76229 had digest 8dd75bb0d5475a93c27c4166677fbb3bc154e6731c7e07ecad549a58851c84a4","title":"blockchain"},{"location":"node-operators/cli/#getbalance","text":"Get total balance of the given account. --pkh=address : Public key hash for which to get balance. If omitted, defaults to the node pkh. witnet node getBalance witnet node getBalance --pkh = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: 34099999950005","title":"getBalance"},{"location":"node-operators/cli/#getpkh","text":"Get the public key hash of the node. This is the address used for mining blocks, resolving data requests, and receiving value transfer transactions. witnet node getPkh Example output: twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr","title":"getPkh"},{"location":"node-operators/cli/#getreputation","text":"Get the reputation of the given account. --pkh=address : Public key hash for which to get balance. If omitted, defaults to the node pkh. witnet node getReputation witnet node getReputation --pkh = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: Identity twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr has 1 reputation and is active witnet node getReputation --all Example output: Total Reputation: { [A] twit1t99a5r6d0lqstl8rdkqw3ywfs2y4zwqhy5zprt: 1 [A] twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr: 1 }","title":"getReputation"},{"location":"node-operators/cli/#raw","text":"The raw command allows sending raw JSON-RPC requests from the command line. It can be used in an interactive way: each line of user input will be sent to the JSON-RPC server without any modifications: $ witnet -c witnet.toml node raw Each block represents a method call: the first line is a request, the second line is a response. hi { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } { \"jsonrpc\" : \"2.0\" , \"method\" : \"getBlockChain\" , \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"result\" : [[ 242037 , \"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\" ]], \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"method\" : \"someInvalidMethod\" , \"id\" : 2 } { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32601 , \"message\" : \"Method not found\" }, \"id\" : 2 } bye { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } Alternatively, the input can be read from a file using pipes, as is usual in Unix-like environments: $ cat get_block_chain.txt | witnet node raw {\"jsonrpc\":\"2.0\",\"result\":[[242037,\"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\"]],\"id\":1}","title":"raw"},{"location":"node-operators/cli/#send","text":"Create a value transfer transaction. --pkh=address : public key hash of the destination. --value=amount : value --fee=fee : fee --time-lock=timestamp : optional time lock for the created output: the receiver will not be able to spend the output until the timestamp is reached. 0 means no time-lock. On success, returns the transaction hash: witnet node send --pkh=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} On error, returns the error message: witnet node send --pkh = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Example with time lock set to 2019-10-01 witnet node send --pkh=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"}","title":"send"},{"location":"node-operators/json-rpc/","text":"","title":"Json rpc"},{"location":"node-operators/wallet-api/","text":"","title":"Wallet api"},{"location":"overview/concepts/","text":"What is Witnet? \u00b6 The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time. Smart Contracts Are Not What You Were Told \u00b6 Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom . Blockchain Oracles, And Their Problem \u00b6 Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" . The Solution: A Decentralized Oracle Network \u00b6 The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it. 100% Truth, 0% Trust \u00b6 Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"What is Witnet?"},{"location":"overview/concepts/#what-is-witnet","text":"The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time.","title":"What is Witnet?"},{"location":"overview/concepts/#smart-contracts-are-not-what-you-were-told","text":"Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom .","title":"Smart Contracts Are Not What You Were Told"},{"location":"overview/concepts/#blockchain-oracles-and-their-problem","text":"Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" .","title":"Blockchain Oracles, And Their Problem"},{"location":"overview/concepts/#the-solution-a-decentralized-oracle-network","text":"The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it.","title":"The Solution: A Decentralized Oracle Network"},{"location":"overview/concepts/#100-truth-0-trust","text":"Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"100% Truth, 0% Trust"},{"location":"overview/glossary/","text":"Glossary \u00b6 Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/glossary/#glossary","text":"Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/software/","text":"Witnet Software ecosystem \u00b6 Witnet-Rust \u00b6 Witnet-Rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust is experimental software running on experimental network protocols: All the main components are in place\u2014but they need yet to be battle tested before mainnet. Testnet-4 is live. Here's the roadmap and this is how to run a node . The Witnet community is doing its best to make witnet-rust rock solid as soon as possible. Contributions are more than welcome. Sheikah \u00b6 Sheikah is a Witnet-compatible desktop wallet, data requests and smart contracts development environment. Ethereum Bridge \u00b6 The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is actually three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust , which monitors the WBI for new requests and also scans","title":"Software"},{"location":"overview/software/#witnet-software-ecosystem","text":"","title":"Witnet Software ecosystem"},{"location":"overview/software/#witnet-rust","text":"Witnet-Rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust is experimental software running on experimental network protocols: All the main components are in place\u2014but they need yet to be battle tested before mainnet. Testnet-4 is live. Here's the roadmap and this is how to run a node . The Witnet community is doing its best to make witnet-rust rock solid as soon as possible. Contributions are more than welcome.","title":"Witnet-Rust"},{"location":"overview/software/#sheikah","text":"Sheikah is a Witnet-compatible desktop wallet, data requests and smart contracts development environment.","title":"Sheikah"},{"location":"overview/software/#ethereum-bridge","text":"The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is actually three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust , which monitors the WBI for new requests and also scans","title":"Ethereum Bridge"},{"location":"protocol/blocks/","text":"","title":"Blocks"},{"location":"protocol/reputation/","text":"Reputation System \u00b6","title":"Reputation System"},{"location":"protocol/reputation/#reputation-system","text":"","title":"Reputation System"},{"location":"protocol/serialization/","text":"","title":"Serialization"},{"location":"protocol/sortition/","text":"","title":"Sortition"},{"location":"protocol/transactions/","text":"","title":"Transactions"},{"location":"protocol/data-requests/examples/","text":"Examples \u00b6 What's the weather in Berlin? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the OpenWeatherMap API that returns the current weather conditions in Berlin. Retrieval stage \u00b6 Javascript new Witnet . Script () . parseJSON () // Parse the string, which we now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"weather\" ) // Get the value associated to the `weather` key . asMap () // Treat that as a Javascript object too . get ( \"temp\" ) // Now get the value associated to the `weather` key . asFloat (); // Finally treat that as a floating point number RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"weather\" ], BYTES_ASMAP , [ MAP_GET , \"temp\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"weather\" ], 116 , [ 97 , \"temp\" ], 114 ] CBOR (Base16) 8618451874821861477765617468657218748218614474656 D701872 Aggregation stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . greaterThan , - 30 ) . filter ( Witnet . Types . FILTERS . lessThan , 50 ) . filter ( Witnet . Types . FILTERS . deviationStandard ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATERTHAN , - 30 ], [ ARRAY_FILTER , FILTER_LESSTHAN , 50 ], [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 0 , - 30 ], [ 83 , 1 , 50 ], [ 83 , 5 ], [ 87 , 3 ] ] CBOR (Base16) 8483185300381 D8318530118328218530582185703 Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and return the arithmetic mean of the remaining values in the Array . Tally stage \u00b6 The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array What's the USD price of a bitcoin? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the Coinbase price API that returns the current price of a bitcoin in US dollars. Retrieval stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"bpi\" ) . asMap () . get ( \"usd\" ) . asMap () . get ( \"rate_float\" ) . asFloat () RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"bpi\" ], BYTES_ASMAP , [ MAP_GET , \"USD\" ], BYTES_ASMAP , [ MAP_GET , \"rate_float\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"bpi\" ], 116 , [ 97 , \"usd\" ], 116 , [ 97 , \"rate_float\" ], 114 ] CBOR (Base16) 88184518748218616362706918748218616375736418748218616 A726174655F666C6F61741872 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map , Take the value of the \"bpi\" key, Treat the structure as Map . Take the value of the \"USD\" key, Treat the structure as Map . Take the value of the \"rate_float\" , Return the value as Float . Aggregation stage \u00b6 The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array Tally stage \u00b6 For the tally stage we can safely use the same generic script as for the aggregation stage. Heads or tails? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the Australian National University Quantum Random Numbers Server that returns true random numbers in the [0, 255] range generated in real-time by measuring the quantum fluctuations of the vacuum in a laboratory. The tally stage computes the average of the values reported by multiple witness nodes, which will produce a point in the [0, 255] range that is normally distributed around the half-range, i.e. it will fall in any of the [0, 127] or [128, 255] sub-ranges with a 50% probability. Finally, it checks in which side of the half-range did the point actually fall and maps that into a String with value heads or tails . Retrieval stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"data\" ) . asArray () . get ( 0 ) . asInteger () RADON-AST [ STRING_PARSEJSON , BYTES_TOMAP , [ MAP_GET , \"data\" ], BYTES_TOARRAY , [ ARRAY_GET , 0 ], BYTES_ASARRAY ] RADON-JSON [ 69 , 116 , [ 97 , \"data\" ], 112 , [ 85 , 0 ], 115 ] CBOR (Base16) 861845187482186144646174611870821855001873 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map<String, Mixed> , Take the value of the \"data\" key as Mixed , Treat the structure as Array<Mixed> . Take the value at index 0 as Mixed , Emit the value as Float . Tally stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . INTEGER ]) . filter ( Witnet . Types . FILTERS . greaterOrEqualThan , 0 ) . filter ( Witnet . Types . FILTERS . lessOrEqualThan , 255 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) . round () . greaterThan ( 127 ) . match ({ true : \"tails\" }, \"heads\" ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATEROREQUALTHAN , 0 ], [ ARRAY_FILTER , FILTER_LESSOREQUALTHAN , 255 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ], FLOAT_ROUND , [ INTEGER_GREATERTHAN , 127 ], [ INTEGER_MATCH , { true : \"tails\" }, \"heads\" ] ] RADON-JSON [ [ 83 , 129 , 0 ], [ 83 , 128 , 255 ], [ 87 , 3 ], 60 , [ 36 , 127 ], [ 16 , { true : 'tails' }, 'heads' ] ] CBOR (Base16) 86831853188100831853188018 FF82185703183C821824187F8310A1F5457461696C73456865616473 Remove any items with value under 0 from Array , Remove any items with value over 255 from the remaining Array , Calculate the arithmetic mean of the remaining Array , Round the resulting Float to its closest Integer value, Check if the resulting Integer is greater than 127 , and continue with a Boolean of value true or false accordingly, Map the Boolean to String by converting false into \"heads\" and true into \"tails\" .","title":"Examples"},{"location":"protocol/data-requests/examples/#examples","text":"","title":"Examples"},{"location":"protocol/data-requests/examples/#whats-the-weather-in-berlin","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the OpenWeatherMap API that returns the current weather conditions in Berlin.","title":"What's the weather in Berlin?"},{"location":"protocol/data-requests/examples/#retrieval-stage","text":"Javascript new Witnet . Script () . parseJSON () // Parse the string, which we now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"weather\" ) // Get the value associated to the `weather` key . asMap () // Treat that as a Javascript object too . get ( \"temp\" ) // Now get the value associated to the `weather` key . asFloat (); // Finally treat that as a floating point number RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"weather\" ], BYTES_ASMAP , [ MAP_GET , \"temp\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"weather\" ], 116 , [ 97 , \"temp\" ], 114 ] CBOR (Base16) 8618451874821861477765617468657218748218614474656 D701872","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#aggregation-stage","text":"Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . greaterThan , - 30 ) . filter ( Witnet . Types . FILTERS . lessThan , 50 ) . filter ( Witnet . Types . FILTERS . deviationStandard ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATERTHAN , - 30 ], [ ARRAY_FILTER , FILTER_LESSTHAN , 50 ], [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 0 , - 30 ], [ 83 , 1 , 50 ], [ 83 , 5 ], [ 87 , 3 ] ] CBOR (Base16) 8483185300381 D8318530118328218530582185703 Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and return the arithmetic mean of the remaining values in the Array .","title":"Aggregation stage"},{"location":"protocol/data-requests/examples/#tally-stage","text":"The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array","title":"Tally stage"},{"location":"protocol/data-requests/examples/#whats-the-usd-price-of-a-bitcoin","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the Coinbase price API that returns the current price of a bitcoin in US dollars.","title":"What's the USD price of a bitcoin?"},{"location":"protocol/data-requests/examples/#retrieval-stage_1","text":"Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"bpi\" ) . asMap () . get ( \"usd\" ) . asMap () . get ( \"rate_float\" ) . asFloat () RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"bpi\" ], BYTES_ASMAP , [ MAP_GET , \"USD\" ], BYTES_ASMAP , [ MAP_GET , \"rate_float\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"bpi\" ], 116 , [ 97 , \"usd\" ], 116 , [ 97 , \"rate_float\" ], 114 ] CBOR (Base16) 88184518748218616362706918748218616375736418748218616 A726174655F666C6F61741872 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map , Take the value of the \"bpi\" key, Treat the structure as Map . Take the value of the \"USD\" key, Treat the structure as Map . Take the value of the \"rate_float\" , Return the value as Float .","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#aggregation-stage_1","text":"The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array","title":"Aggregation stage"},{"location":"protocol/data-requests/examples/#tally-stage_1","text":"For the tally stage we can safely use the same generic script as for the aggregation stage.","title":"Tally stage"},{"location":"protocol/data-requests/examples/#heads-or-tails","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the Australian National University Quantum Random Numbers Server that returns true random numbers in the [0, 255] range generated in real-time by measuring the quantum fluctuations of the vacuum in a laboratory. The tally stage computes the average of the values reported by multiple witness nodes, which will produce a point in the [0, 255] range that is normally distributed around the half-range, i.e. it will fall in any of the [0, 127] or [128, 255] sub-ranges with a 50% probability. Finally, it checks in which side of the half-range did the point actually fall and maps that into a String with value heads or tails .","title":"Heads or tails?"},{"location":"protocol/data-requests/examples/#retrieval-stage_2","text":"Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"data\" ) . asArray () . get ( 0 ) . asInteger () RADON-AST [ STRING_PARSEJSON , BYTES_TOMAP , [ MAP_GET , \"data\" ], BYTES_TOARRAY , [ ARRAY_GET , 0 ], BYTES_ASARRAY ] RADON-JSON [ 69 , 116 , [ 97 , \"data\" ], 112 , [ 85 , 0 ], 115 ] CBOR (Base16) 861845187482186144646174611870821855001873 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map<String, Mixed> , Take the value of the \"data\" key as Mixed , Treat the structure as Array<Mixed> . Take the value at index 0 as Mixed , Emit the value as Float .","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#tally-stage_2","text":"Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . INTEGER ]) . filter ( Witnet . Types . FILTERS . greaterOrEqualThan , 0 ) . filter ( Witnet . Types . FILTERS . lessOrEqualThan , 255 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) . round () . greaterThan ( 127 ) . match ({ true : \"tails\" }, \"heads\" ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATEROREQUALTHAN , 0 ], [ ARRAY_FILTER , FILTER_LESSOREQUALTHAN , 255 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ], FLOAT_ROUND , [ INTEGER_GREATERTHAN , 127 ], [ INTEGER_MATCH , { true : \"tails\" }, \"heads\" ] ] RADON-JSON [ [ 83 , 129 , 0 ], [ 83 , 128 , 255 ], [ 87 , 3 ], 60 , [ 36 , 127 ], [ 16 , { true : 'tails' }, 'heads' ] ] CBOR (Base16) 86831853188100831853188018 FF82185703183C821824187F8310A1F5457461696C73456865616473 Remove any items with value under 0 from Array , Remove any items with value over 255 from the remaining Array , Calculate the arithmetic mean of the remaining Array , Round the resulting Float to its closest Integer value, Check if the resulting Integer is greater than 127 , and continue with a Boolean of value true or false accordingly, Map the Boolean to String by converting false into \"heads\" and true into \"tails\" .","title":"Tally stage"},{"location":"protocol/data-requests/overview/","text":"Witnet requests \u00b6 Witnet requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand. Request life cycle \u00b6 Once a Witnet request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s. For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide. The RAD Engine \u00b6 The RAD Engine is the component in charge of processing Witnet requests. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All Witnet requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Aggregate and Deliver . RAD Object Notation (RADON) \u00b6 The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted. Creating Witnet requests \u00b6 The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can safely write RADON without their heads exploding, they are just not expected to. The main way to compose Witnet requests is using the Witnet Truffle box , which you can learn about by following the price feed tutorial . The Sheikah desktop app (currently under heavy development) is also intended to be used as an IDE for visually and safely composing and testing Witnet requests.","title":"Overview"},{"location":"protocol/data-requests/overview/#witnet-requests","text":"Witnet requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand.","title":"Witnet requests"},{"location":"protocol/data-requests/overview/#request-life-cycle","text":"Once a Witnet request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s. For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide.","title":"Request life cycle"},{"location":"protocol/data-requests/overview/#the-rad-engine","text":"The RAD Engine is the component in charge of processing Witnet requests. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All Witnet requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Aggregate and Deliver .","title":"The RAD Engine"},{"location":"protocol/data-requests/overview/#rad-object-notation-radon","text":"The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted.","title":"RAD Object Notation (RADON)"},{"location":"protocol/data-requests/overview/#creating-witnet-requests","text":"The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can safely write RADON without their heads exploding, they are just not expected to. The main way to compose Witnet requests is using the Witnet Truffle box , which you can learn about by following the price feed tutorial . The Sheikah desktop app (currently under heavy development) is also intended to be used as an IDE for visually and safely composing and testing Witnet requests.","title":"Creating Witnet requests"},{"location":"protocol/data-requests/radon-encoding/","text":"RADON encoding \u00b6 RADON scripts are encoded using CBOR , a very efficient, compact and widely supported data structure encoding. Look for example at this impressively short (28 bytes) serialized RADON script: // As Hex string 8618431874821861677765617468657218748218616474656 D701872 // As Base64 string \"hhhDGHSCGGFnd2VhdGhlchh0ghhhZHRlbXAYcg==\" Once decoded, the resulting structure will actually represent this RADON script: [ STRING_PARSEJSON , // 0x45 MIXED_ASMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_ASMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_ASFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences but at the same time represent high-level abstractions. In the Javascript-like representation of RADON that the Witnet Truffle box uses, the script above may resemble: new Witnet . Script () . parseJSON () . asMap () . get ( \"weather\" ) . asMap () . get ( \"temp\" ) . asFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"Encoding"},{"location":"protocol/data-requests/radon-encoding/#radon-encoding","text":"RADON scripts are encoded using CBOR , a very efficient, compact and widely supported data structure encoding. Look for example at this impressively short (28 bytes) serialized RADON script: // As Hex string 8618431874821861677765617468657218748218616474656 D701872 // As Base64 string \"hhhDGHSCGGFnd2VhdGhlchh0ghhhZHRlbXAYcg==\" Once decoded, the resulting structure will actually represent this RADON script: [ STRING_PARSEJSON , // 0x45 MIXED_ASMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_ASMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_ASFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences but at the same time represent high-level abstractions. In the Javascript-like representation of RADON that the Witnet Truffle box uses, the script above may resemble: new Witnet . Script () . parseJSON () . asMap () . get ( \"weather\" ) . asMap () . get ( \"temp\" ) . asFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"RADON encoding"},{"location":"try/run-a-node/","text":"Running a Node in the Witnet Testnet \u00b6 The Witnet testnet is open for anyone to join and test it by running their own full node. Running a node on the Witnet mainnet is not possible before the mainnet is released. Check out the roadmap and save the dates! You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to connect your Ethereum contracts to external APIs using Witnet . Using Docker \u00b6 The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. This docker image downloads and runs a witnet-rust node in the latest testnet in just a matter on seconds. If that's exactly what you want, you can just run this and enjoy: docker run -it witnet/witnet-rust latest node server How to enable persistence \u00b6 Be careful though, as running the image without mounting any volumes may cause total loss of data (including private keys and thus any mined wits). Luckily, enabling persistence is super easy: docker run \\ -v ~/.witnet-rust-testnet-4:/.witnet-rust-testnet-4 \\ -it witnet/witnet-rust latest node server How to run specific releases \u00b6 Specific versions or releases can be simply run form the the same image: docker run \\ -v ~/.witnet-rust-testnet-4:/.witnet-rust-testnet-4 \\ -it witnet/witnet-rust 0 .3.2 node server How to execute CLI commands on the running node \u00b6 First you need to get the CONTAINER ID or NAME of the running node with: docker ps Then, you can run CLI commands on the running node with this simple one-liner. In this example, it will show the latest blocks in the chain: docker exec -i <container_id> ./witnet node blockchain Debug mode \u00b6 Debug mode shows more info on what is happening under the hood. It is activated with the --debug flag in the right place: docker run -it witnet/witnet-rust latest --debug node server Passing the RUST_LOG=witnet=debug environment flag does the same: docker run \\ -e RUST_LOG = witnet = debug \\ -it witnet/witnet-rust latest node server","title":"Run a Node"},{"location":"try/run-a-node/#running-a-node-in-the-witnet-testnet","text":"The Witnet testnet is open for anyone to join and test it by running their own full node. Running a node on the Witnet mainnet is not possible before the mainnet is released. Check out the roadmap and save the dates! You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to connect your Ethereum contracts to external APIs using Witnet .","title":"Running a Node in the Witnet Testnet"},{"location":"try/run-a-node/#using-docker","text":"The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. This docker image downloads and runs a witnet-rust node in the latest testnet in just a matter on seconds. If that's exactly what you want, you can just run this and enjoy: docker run -it witnet/witnet-rust latest node server","title":"Using Docker"},{"location":"try/run-a-node/#how-to-enable-persistence","text":"Be careful though, as running the image without mounting any volumes may cause total loss of data (including private keys and thus any mined wits). Luckily, enabling persistence is super easy: docker run \\ -v ~/.witnet-rust-testnet-4:/.witnet-rust-testnet-4 \\ -it witnet/witnet-rust latest node server","title":"How to enable persistence"},{"location":"try/run-a-node/#how-to-run-specific-releases","text":"Specific versions or releases can be simply run form the the same image: docker run \\ -v ~/.witnet-rust-testnet-4:/.witnet-rust-testnet-4 \\ -it witnet/witnet-rust 0 .3.2 node server","title":"How to run specific releases"},{"location":"try/run-a-node/#how-to-execute-cli-commands-on-the-running-node","text":"First you need to get the CONTAINER ID or NAME of the running node with: docker ps Then, you can run CLI commands on the running node with this simple one-liner. In this example, it will show the latest blocks in the chain: docker exec -i <container_id> ./witnet node blockchain","title":"How to execute CLI commands on the running node"},{"location":"try/run-a-node/#debug-mode","text":"Debug mode shows more info on what is happening under the hood. It is activated with the --debug flag in the right place: docker run -it witnet/witnet-rust latest --debug node server Passing the RUST_LOG=witnet=debug environment flag does the same: docker run \\ -e RUST_LOG = witnet = debug \\ -it witnet/witnet-rust latest node server","title":"Debug mode"},{"location":"try/use-from-ethereum/","text":"Using Witnet from Ethereum / Solidity \u00b6 Using Witnet as an oracle for resolving your Ethereum smart contracts is really easy thanks to the Witnet Truffle box and the UsingWitnet Solidity library. Write your first Witnet-powered Ethereum contract \u00b6 The Witnet community has put together this comprehensive tutorial on how to create a price feed Ethereum contract using Solidity, Truffle and Witnet so that you can get started in a matter of minutes. How can Ethereum contracts communicate with Witnet? \u00b6 Witnet is a separate blockchain. However, communication between Ethereum and Witnet is actually made possible thanks to the Witnet Bridge Interface and the bridge nodes , which are nodes that operate in both blockchains and get randomly selected for performing the job of relaying requests and responses back and forth between the two. This system, which resembles the architecture of a sidechain, is better described in this Medium post . Do I need Wit tokens for using Witnet from Ethereum? \u00b6 No! Using Witnet from Ethereum is specially convenient because you do not need to own or pay any Wit tokens: you pay the bridge nodes using ETH and then they spend their own Wit tokens when posting your requests into Witnet in your behalf.","title":"Connect your Ethereum contracts to external APIs"},{"location":"try/use-from-ethereum/#using-witnet-from-ethereum-solidity","text":"Using Witnet as an oracle for resolving your Ethereum smart contracts is really easy thanks to the Witnet Truffle box and the UsingWitnet Solidity library.","title":"Using Witnet from Ethereum / Solidity"},{"location":"try/use-from-ethereum/#write-your-first-witnet-powered-ethereum-contract","text":"The Witnet community has put together this comprehensive tutorial on how to create a price feed Ethereum contract using Solidity, Truffle and Witnet so that you can get started in a matter of minutes.","title":"Write your first Witnet-powered Ethereum contract"},{"location":"try/use-from-ethereum/#how-can-ethereum-contracts-communicate-with-witnet","text":"Witnet is a separate blockchain. However, communication between Ethereum and Witnet is actually made possible thanks to the Witnet Bridge Interface and the bridge nodes , which are nodes that operate in both blockchains and get randomly selected for performing the job of relaying requests and responses back and forth between the two. This system, which resembles the architecture of a sidechain, is better described in this Medium post .","title":"How can Ethereum contracts communicate with Witnet?"},{"location":"try/use-from-ethereum/#do-i-need-wit-tokens-for-using-witnet-from-ethereum","text":"No! Using Witnet from Ethereum is specially convenient because you do not need to own or pay any Wit tokens: you pay the bridge nodes using ETH and then they spend their own Wit tokens when posting your requests into Witnet in your behalf.","title":"Do I need Wit tokens for using Witnet from Ethereum?"},{"location":"tutorials/bitcoin-price-feed/aggregations/","text":"3. Define aggregation and tally functions \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. What is an aggregation function? \u00b6 An aggregation function is a Witnet script that defines how to reduce the result of multiple sources into a single data point. They are similar to Javascript's .reduce () method or the fold higher-order function from many programming languages. Every Witnet request needs to have one and only one aggregation function . Aggregation functions always start with an Array containing the output value of each of the source scripts. When a Witnet node is assigned a request it retrieves every source, applies the source companion scripts on the retrieved data, collect those into an Array , then apply the aggregation script on it. What is a tally function? \u00b6 Tally functions are really similar to aggregation functions, but instead of aggregating multiple sources, they aggregate the results reported by multiple Witnet nodes. Let's average multiple sources \u00b6 In this case, you will be using an aggregation function that returns the average mean of the Float values coming from the two sources that you defined before: // Computes the average mean of the two sources using a reducer const aggregator = new Witnet . Aggregator ([ bitstamp , coindesk ]) // Create a new aggregation . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean That will be enough to reduce the Array containing the Float responses of the two sources into a single Float that represents the average mean. You can now continue with the tally function. Tally by average \u00b6 For this tutorial, you will be using a tally function that is quite equivalent as the aggregation function: // Computes the average mean of the values reported by multiple nodes using a reducer const tally = new Witnet . Tally ( aggregator ) // Create a new tally function . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean Quick recap \u00b6 At this point, requests/BitcoinPrice.js should look like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number // Computes the average mean of the two sources using a reducer const aggregator = new Witnet . Aggregator ([ bitstamp , coindesk ]) // Create a new aggregation . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean // Computes the average mean of the values reported by multiple nodes using a reducer const tally = new Witnet . Tally ( aggregator ) // Create a new tally function . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean Now it is time to put everything together and fine-tune the request . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"3. Define aggregations"},{"location":"tutorials/bitcoin-price-feed/aggregations/#3-define-aggregation-and-tally-functions","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"3. Define aggregation and tally functions"},{"location":"tutorials/bitcoin-price-feed/aggregations/#what-is-an-aggregation-function","text":"An aggregation function is a Witnet script that defines how to reduce the result of multiple sources into a single data point. They are similar to Javascript's .reduce () method or the fold higher-order function from many programming languages. Every Witnet request needs to have one and only one aggregation function . Aggregation functions always start with an Array containing the output value of each of the source scripts. When a Witnet node is assigned a request it retrieves every source, applies the source companion scripts on the retrieved data, collect those into an Array , then apply the aggregation script on it.","title":"What is an aggregation function?"},{"location":"tutorials/bitcoin-price-feed/aggregations/#what-is-a-tally-function","text":"Tally functions are really similar to aggregation functions, but instead of aggregating multiple sources, they aggregate the results reported by multiple Witnet nodes.","title":"What is a tally function?"},{"location":"tutorials/bitcoin-price-feed/aggregations/#lets-average-multiple-sources","text":"In this case, you will be using an aggregation function that returns the average mean of the Float values coming from the two sources that you defined before: // Computes the average mean of the two sources using a reducer const aggregator = new Witnet . Aggregator ([ bitstamp , coindesk ]) // Create a new aggregation . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean That will be enough to reduce the Array containing the Float responses of the two sources into a single Float that represents the average mean. You can now continue with the tally function.","title":"Let's average multiple sources"},{"location":"tutorials/bitcoin-price-feed/aggregations/#tally-by-average","text":"For this tutorial, you will be using a tally function that is quite equivalent as the aggregation function: // Computes the average mean of the values reported by multiple nodes using a reducer const tally = new Witnet . Tally ( aggregator ) // Create a new tally function . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean","title":"Tally by average"},{"location":"tutorials/bitcoin-price-feed/aggregations/#quick-recap","text":"At this point, requests/BitcoinPrice.js should look like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number // Computes the average mean of the two sources using a reducer const aggregator = new Witnet . Aggregator ([ bitstamp , coindesk ]) // Create a new aggregation . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean // Computes the average mean of the values reported by multiple nodes using a reducer const tally = new Witnet . Tally ( aggregator ) // Create a new tally function . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean Now it is time to put everything together and fine-tune the request . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"Quick recap"},{"location":"tutorials/bitcoin-price-feed/compiling/","text":"5. Compile the request \u00b6 This article is part of the [beginner tutorial on creating a totally decentralized Bitcoin price feed][intro] on Ethereum with Solidity and Witnet. Compiling the request could not be easier: npm npm run compile-requests yarn yarn compile-requests The compile-requests npm task will: Analyze your requests for syntactic and semantic errors. Warn you of any security issues and broken incentives. Try to compile the requests into Witnet bytecode. Put the bytecode into auxiliary Solidity contracts that you can import into your own contracts. Write migration files with default constructor arguments that you can later customize. If you go and look at the contracts/requests folder, you will notice a new file called BitcoinPrice.sol . It will contain something like this: pragma solidity ^ 0.5 . 0 ; import \"witnet-ethereum-bridge/contracts/Request.sol\" ; // The bytecode of the BitcoinPrice request that will be sent to Witnet contract BitcoinPriceRequest is Request { constructor () Request ( hex \"0aaf0108b6cfb3ec051237122468747470733a2f2f7777772e6269747374616d702e6e65742f6170692f7469636b65722f1a0f8418451874821861646c6173741872125c123168747470733a2f2f6170692e636f696e6465736b2e636f6d2f76312f6270692f63757272656e7470726963652e6a736f6e1a2788184518748218616362706918748218616355534418748218616a726174655f666c6f617418721a070a05818218570322070a058182185703100a18042002280130013801\" ) public { } } As you can see, the contract contains the byte code for the request you just wrote, exported as a Solidity contract that you can in turn import and instantiate from your own contracts. Now the next step is pretty straightforward: write your main consumer contract . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"5. Compile the request"},{"location":"tutorials/bitcoin-price-feed/compiling/#5-compile-the-request","text":"This article is part of the [beginner tutorial on creating a totally decentralized Bitcoin price feed][intro] on Ethereum with Solidity and Witnet. Compiling the request could not be easier: npm npm run compile-requests yarn yarn compile-requests The compile-requests npm task will: Analyze your requests for syntactic and semantic errors. Warn you of any security issues and broken incentives. Try to compile the requests into Witnet bytecode. Put the bytecode into auxiliary Solidity contracts that you can import into your own contracts. Write migration files with default constructor arguments that you can later customize. If you go and look at the contracts/requests folder, you will notice a new file called BitcoinPrice.sol . It will contain something like this: pragma solidity ^ 0.5 . 0 ; import \"witnet-ethereum-bridge/contracts/Request.sol\" ; // The bytecode of the BitcoinPrice request that will be sent to Witnet contract BitcoinPriceRequest is Request { constructor () Request ( hex \"0aaf0108b6cfb3ec051237122468747470733a2f2f7777772e6269747374616d702e6e65742f6170692f7469636b65722f1a0f8418451874821861646c6173741872125c123168747470733a2f2f6170692e636f696e6465736b2e636f6d2f76312f6270692f63757272656e7470726963652e6a736f6e1a2788184518748218616362706918748218616355534418748218616a726174655f666c6f617418721a070a05818218570322070a058182185703100a18042002280130013801\" ) public { } } As you can see, the contract contains the byte code for the request you just wrote, exported as a Solidity contract that you can in turn import and instantiate from your own contracts. Now the next step is pretty straightforward: write your main consumer contract . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"5. Compile the request"},{"location":"tutorials/bitcoin-price-feed/contract/","text":"6. Write your consumer contract that will handle price feed updates \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Plan the contract \u00b6 Your contract will maintain a public variable in its state that will contain the price of a bitcoin in US Dollars. An update of the price point can be requested on demand by any interested party: Anyone will be able to call a requestUpdate method in the contract that creates a new instance of the BitcoinPrice.sol contract and send it to Witnet. Once the request gets resolved, anyone will be able to call the completeUpdate to actually write the result into the contract state. It is an assumption that the mere existence of a multiparty contract that consumes the price feed will be enough incentive for the interested parties to request and complete the update always that the price point inside the contract differs from the actual market price more than the cost of performing the Witnet request. Initialize a basic contract \u00b6 Let's start by creating a really bare-bones contract and saving it as contracts/PriceFeed.sol : pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } } What you are doing here is quite straightforward: Import UsingWitnet.sol so your contract is Witnet-enabled. Import BitcoinPrice.sol so that you can instantiate the Witnet request when needed. Make your contract inherit UsingWitnet . Make the constructor receive the address of the Witnet Bridge Interface ( _wbi ) and pass it down to the UsingWitnet constructor through UsingWitnet(_wbi) Write the requestUpdate method that launches the Witnet request \u00b6 function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 micro // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 micro // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); } Write the resolveUpdate method that reads the result of the Witnet request \u00b6 // The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows to // protect your methods from being called before the request has been successfully // relayed into Witnet. function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point if ( result . isOk ()) { bitcoinPrice = result . asInt128 (); } // In any case, set `pending` to false so a new update can be requested pending = false ; } Quick recap \u00b6 This is what the complete contract looks like: pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 micro // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 micro // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); } function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point if ( result . isOk ()) bitcoinPrice = result . asInt128 (); } // In any case, set `pending` to false so a new update can be requested pending = false ; } } Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"6. Write the Solidity contract"},{"location":"tutorials/bitcoin-price-feed/contract/#6-write-your-consumer-contract-that-will-handle-price-feed-updates","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"6. Write your consumer contract that will handle price feed updates"},{"location":"tutorials/bitcoin-price-feed/contract/#plan-the-contract","text":"Your contract will maintain a public variable in its state that will contain the price of a bitcoin in US Dollars. An update of the price point can be requested on demand by any interested party: Anyone will be able to call a requestUpdate method in the contract that creates a new instance of the BitcoinPrice.sol contract and send it to Witnet. Once the request gets resolved, anyone will be able to call the completeUpdate to actually write the result into the contract state. It is an assumption that the mere existence of a multiparty contract that consumes the price feed will be enough incentive for the interested parties to request and complete the update always that the price point inside the contract differs from the actual market price more than the cost of performing the Witnet request.","title":"Plan the contract"},{"location":"tutorials/bitcoin-price-feed/contract/#initialize-a-basic-contract","text":"Let's start by creating a really bare-bones contract and saving it as contracts/PriceFeed.sol : pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } } What you are doing here is quite straightforward: Import UsingWitnet.sol so your contract is Witnet-enabled. Import BitcoinPrice.sol so that you can instantiate the Witnet request when needed. Make your contract inherit UsingWitnet . Make the constructor receive the address of the Witnet Bridge Interface ( _wbi ) and pass it down to the UsingWitnet constructor through UsingWitnet(_wbi)","title":"Initialize a basic contract"},{"location":"tutorials/bitcoin-price-feed/contract/#write-the-requestupdate-method-that-launches-the-witnet-request","text":"function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 micro // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 micro // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); }","title":"Write the requestUpdate method that launches the Witnet request"},{"location":"tutorials/bitcoin-price-feed/contract/#write-the-resolveupdate-method-that-reads-the-result-of-the-witnet-request","text":"// The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows to // protect your methods from being called before the request has been successfully // relayed into Witnet. function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point if ( result . isOk ()) { bitcoinPrice = result . asInt128 (); } // In any case, set `pending` to false so a new update can be requested pending = false ; }","title":"Write the resolveUpdate method that reads the result of the Witnet request"},{"location":"tutorials/bitcoin-price-feed/contract/#quick-recap","text":"This is what the complete contract looks like: pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 micro // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 micro // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); } function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point if ( result . isOk ()) bitcoinPrice = result . asInt128 (); } // In any case, set `pending` to false so a new update can be requested pending = false ; } } Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"Quick recap"},{"location":"tutorials/bitcoin-price-feed/create-project/","text":"1. Create a new Witnet-enabled project \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Using the Witnet Truffle Box \u00b6 If you are creating a new project from scratch, the quickest way to get things working is using Truffle to download a Witnet-enabled project template: GNU/Linux, Mac OS or Linux Subsystem for Windows mkdir bitcoin-price-feed cd bitcoin-price-feed truffle unbox witnet/truffle-box You can keep reading this page to learn more about the Truffle box boilerplate, but if you are feeling impatient you can jump into the next step . Project folder structure \u00b6 After unboxing you should find yourself in a project that has been populated with the following directory structure: bitcoin-price-feed \u251c\u2500\u2500 contracts // Where your Solidity contracts will be \u2502 \u2514\u2500\u2500 requests // Where Witnet requests end up after compilation \u251c\u2500\u2500 migrations // Deployment scripts \u251c\u2500\u2500 requests // Witnet request source code (.js files) \u251c\u2500\u2500 test // Scripts for testing your contracts \u2514\u2500\u2500 witnet // Witnet libraries\u2060\u2060\u2014nothing too interesting Next step: define aggregations \u00b6 You are now ready to move forward into defining the data sources to be used . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"1. Create a new project"},{"location":"tutorials/bitcoin-price-feed/create-project/#1-create-a-new-witnet-enabled-project","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"1. Create a new Witnet-enabled project"},{"location":"tutorials/bitcoin-price-feed/create-project/#using-the-witnet-truffle-box","text":"If you are creating a new project from scratch, the quickest way to get things working is using Truffle to download a Witnet-enabled project template: GNU/Linux, Mac OS or Linux Subsystem for Windows mkdir bitcoin-price-feed cd bitcoin-price-feed truffle unbox witnet/truffle-box You can keep reading this page to learn more about the Truffle box boilerplate, but if you are feeling impatient you can jump into the next step .","title":"Using the Witnet Truffle Box"},{"location":"tutorials/bitcoin-price-feed/create-project/#project-folder-structure","text":"After unboxing you should find yourself in a project that has been populated with the following directory structure: bitcoin-price-feed \u251c\u2500\u2500 contracts // Where your Solidity contracts will be \u2502 \u2514\u2500\u2500 requests // Where Witnet requests end up after compilation \u251c\u2500\u2500 migrations // Deployment scripts \u251c\u2500\u2500 requests // Witnet request source code (.js files) \u251c\u2500\u2500 test // Scripts for testing your contracts \u2514\u2500\u2500 witnet // Witnet libraries\u2060\u2060\u2014nothing too interesting","title":"Project folder structure"},{"location":"tutorials/bitcoin-price-feed/create-project/#next-step-define-aggregations","text":"You are now ready to move forward into defining the data sources to be used . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"Next step: define aggregations"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/","text":"4. Put everything together and fine-tune the Witnet request \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Put everything together \u00b6 Time to put everything together and create the Witnet.Request object that you will need to export: // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 4 , 2 ) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } The .setQuorum , .setFees and .schedule methods are explained below. Fine-tune fees, quorum and schedule \u00b6 Witnet requests are highly parameterizable. You can fine-tune almost every single aspect of their life cycle: .setQuorum () sets how many Witnet nodes will be \"hired\" for resolving the request. .setFees () specifies how much you want to pay for rewarding each of the Witnet nodes implicated in resolving the request. .schedule () schedules the request to be resolved in a particular date and time in the future. Set the quorum \u00b6 . setQuorum ( witnesses_count , backup_witnesses_count ) The witnesses_count is the minimum number of Witnet nodes that will be resolving each specific request. In general, the higher the count, the safer the request. However, fees should be proportional to this number. The actual number of nodes that will resolve each request is guaranteed to be equal or greater than the specified count. If for some reason the network fails to assign the request to enough nodes, it will be reassigned in every subsequent epoch to a different randomly-selected set of nodes until the count is reached. The backup_witnesses_count is the number of Witnet nodes that will be used as a backup in case some of the originally assigned nodes fail to fulfill their commitments. A higher backup_witnesses_count implies more fees but also guarantees that the request will be timely resolved. In the other hand, if you use small backup_witnesses_count values, the risk is that your request will need to be retried many times and therefore the result may be potentially inaccurate (in case the queried data point changes very fast). Set the fees \u00b6 . setFees ( reward , commit_fee , reveal_fee , tally_fee ) Witnet allows parametrization of many of the economic incentives that affect the life cycle of your requests. Namely, those incentives are: reward : the amount of wit tokens that every each of the Witnet nodes assigned to your request will earn if they honestly fulfill their commitments and reveals. commit_fee : the amount of wit tokens that will be earned by the first Witnet miner that puts in a block as many commitment transactions as the witnesses_count . reveal_fee : the amount of wit tokens that will be earned by the first Witnet miner that puts in a block as many reveal transactions as the witnesses_count . tally_fee : the amount of wit tokens that will be earned by the first Witnet miner that publishes in a block the tally of all the reveal transactions related to your request. Set the schedule \u00b6 . schedule ( timestamp ) Witnet requests can be scheduled for resolution in a particular date and time in the future. Timestamps need to be provided as POSIX timestamps , i.e. seconds elapsed from 00:00:00 UTC on 1 January 1970 until the desired date. Double check \u00b6 Time to double check everything is fine. Your BitcoinPrice.js file should look more or less like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number // Computes the average mean of the two sources using a reducer const aggregator = new Witnet . Aggregator ([ bitstamp , coindesk ]) // Create a new aggregation . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean // Computes the average mean of the values reported by multiple nodes using a reducer const tally = new Witnet . Tally ( aggregator ) // Create a new tally function . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 4 , 2 ) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } Time to go ahead and compile the request . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"4. Fine-tune the request"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#4-put-everything-together-and-fine-tune-the-witnet-request","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"4. Put everything together and fine-tune the Witnet request"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#put-everything-together","text":"Time to put everything together and create the Witnet.Request object that you will need to export: // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 4 , 2 ) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } The .setQuorum , .setFees and .schedule methods are explained below.","title":"Put everything together"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#fine-tune-fees-quorum-and-schedule","text":"Witnet requests are highly parameterizable. You can fine-tune almost every single aspect of their life cycle: .setQuorum () sets how many Witnet nodes will be \"hired\" for resolving the request. .setFees () specifies how much you want to pay for rewarding each of the Witnet nodes implicated in resolving the request. .schedule () schedules the request to be resolved in a particular date and time in the future.","title":"Fine-tune fees, quorum and schedule"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-quorum","text":". setQuorum ( witnesses_count , backup_witnesses_count ) The witnesses_count is the minimum number of Witnet nodes that will be resolving each specific request. In general, the higher the count, the safer the request. However, fees should be proportional to this number. The actual number of nodes that will resolve each request is guaranteed to be equal or greater than the specified count. If for some reason the network fails to assign the request to enough nodes, it will be reassigned in every subsequent epoch to a different randomly-selected set of nodes until the count is reached. The backup_witnesses_count is the number of Witnet nodes that will be used as a backup in case some of the originally assigned nodes fail to fulfill their commitments. A higher backup_witnesses_count implies more fees but also guarantees that the request will be timely resolved. In the other hand, if you use small backup_witnesses_count values, the risk is that your request will need to be retried many times and therefore the result may be potentially inaccurate (in case the queried data point changes very fast).","title":"Set the quorum"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-fees","text":". setFees ( reward , commit_fee , reveal_fee , tally_fee ) Witnet allows parametrization of many of the economic incentives that affect the life cycle of your requests. Namely, those incentives are: reward : the amount of wit tokens that every each of the Witnet nodes assigned to your request will earn if they honestly fulfill their commitments and reveals. commit_fee : the amount of wit tokens that will be earned by the first Witnet miner that puts in a block as many commitment transactions as the witnesses_count . reveal_fee : the amount of wit tokens that will be earned by the first Witnet miner that puts in a block as many reveal transactions as the witnesses_count . tally_fee : the amount of wit tokens that will be earned by the first Witnet miner that publishes in a block the tally of all the reveal transactions related to your request.","title":"Set the fees"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-schedule","text":". schedule ( timestamp ) Witnet requests can be scheduled for resolution in a particular date and time in the future. Timestamps need to be provided as POSIX timestamps , i.e. seconds elapsed from 00:00:00 UTC on 1 January 1970 until the desired date.","title":"Set the schedule"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#double-check","text":"Time to double check everything is fine. Your BitcoinPrice.js file should look more or less like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number // Computes the average mean of the two sources using a reducer const aggregator = new Witnet . Aggregator ([ bitstamp , coindesk ]) // Create a new aggregation . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean // Computes the average mean of the values reported by multiple nodes using a reducer const tally = new Witnet . Tally ( aggregator ) // Create a new tally function . reduce ( Witnet . Types . REDUCERS . averageMean ) // Reduce the input `Array` using the average mean // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 4 , 2 ) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } Time to go ahead and compile the request . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"Double check"},{"location":"tutorials/bitcoin-price-feed/introduction/","text":"Basic Witnet tutorial: how to create a decentralized Bitcoin price feed on Ethereum with Solidity and Witnet \u00b6 What and why \u00b6 In this tutorial you will: Query two different APIs for the USD price of 1 bitcoin using 4 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be trustlessly consumed by an Ethereum smart contract. Write a Solidity contract that keeps the bitcoin price in a public variable and handles updates using Witnet. Compile and deploy the entire flow into a local Ethereum network. Remember: using Witnet from Ethereum is specially convenient because you do not need to own or pay any Wit tokens: you pay the bridge nodes using ETH and then they spend their own Wit tokens when posting your requests into Witnet in your behalf. How decentralized will this price feed be \u00b6 None of the parties involved in the process of deploying, updating and using the price feed will have any power to tamper with the integrity of the data points it provides: Once deployed, no one will be able to prevent the price feed from being updated or queried . Nobody can set the price directly . The only way to update it is through a Witnet request. The price is averaged from two different public APIs, thus mitigating their influence in the final price. The data is relayed by 4 different Witnet nodes, whose reported data points get aggregated and averaged, filtering out any outliers so as to cancel any malicious reporter who may try to leverage a slight drift of the data point. Show me the code upfront \u00b6 The final result of this tutorial is available in this GitHub repository . You can also check it out with Truffle: mkdir PriceFeed cd PriceFeed truffle unbox stampery-labs/witnet-pricefeed-example Let's do it! \u00b6 Ready to start? Let's begin by creating a new Witnet-enabled Solidity project . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"Introduction"},{"location":"tutorials/bitcoin-price-feed/introduction/#basic-witnet-tutorial-how-to-create-a-decentralized-bitcoin-price-feed-on-ethereum-with-solidity-and-witnet","text":"","title":"Basic Witnet tutorial: how to create a decentralized Bitcoin price feed on Ethereum with Solidity and Witnet"},{"location":"tutorials/bitcoin-price-feed/introduction/#what-and-why","text":"In this tutorial you will: Query two different APIs for the USD price of 1 bitcoin using 4 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be trustlessly consumed by an Ethereum smart contract. Write a Solidity contract that keeps the bitcoin price in a public variable and handles updates using Witnet. Compile and deploy the entire flow into a local Ethereum network. Remember: using Witnet from Ethereum is specially convenient because you do not need to own or pay any Wit tokens: you pay the bridge nodes using ETH and then they spend their own Wit tokens when posting your requests into Witnet in your behalf.","title":"What and why"},{"location":"tutorials/bitcoin-price-feed/introduction/#how-decentralized-will-this-price-feed-be","text":"None of the parties involved in the process of deploying, updating and using the price feed will have any power to tamper with the integrity of the data points it provides: Once deployed, no one will be able to prevent the price feed from being updated or queried . Nobody can set the price directly . The only way to update it is through a Witnet request. The price is averaged from two different public APIs, thus mitigating their influence in the final price. The data is relayed by 4 different Witnet nodes, whose reported data points get aggregated and averaged, filtering out any outliers so as to cancel any malicious reporter who may try to leverage a slight drift of the data point.","title":"How decentralized will this price feed be"},{"location":"tutorials/bitcoin-price-feed/introduction/#show-me-the-code-upfront","text":"The final result of this tutorial is available in this GitHub repository . You can also check it out with Truffle: mkdir PriceFeed cd PriceFeed truffle unbox stampery-labs/witnet-pricefeed-example","title":"Show me the code upfront"},{"location":"tutorials/bitcoin-price-feed/introduction/#lets-do-it","text":"Ready to start? Let's begin by creating a new Witnet-enabled Solidity project . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"Let's do it!"},{"location":"tutorials/bitcoin-price-feed/migrations/","text":"7. Migrate the contracts into an Ethereum network \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Compile your Solidity contract \u00b6 First off, run the compile command, which compiles your Solidity contracts and recompiles the Witnet requests too: npm npm run compile yarn yarn compile You got migration scripts, for free! \u00b6 Migration scripts are one of the nicest features of Truffle. They allow you to configure how your contracts will be deployed on different Ethereum networks, set your contract's constructor arguments and link dynamic dependencies. The Witnet requests compiler that lives inside the Truffle box quietly did something else than compiling your requests into Solidity contracts\u2014 it also wrote autogenerated migration scripts for your own contracts . If you look at the migrations folder, you should find these three files: 1_initial_migration.js : basic Truffle infrastructure migrations. 2_witnet_core.js : deploys all the Witnet-related contracts in case you are deploying on a local or private network; or dynamically link them if you are on a public network (Ethereum Mainnet, Rinkeby or G\u00f6rli). 3_user_contracts.js : contains autogenerated migration scripts for your consumer contracts. Let's take a look at migrations/3_user_contracts.js : // This file was auto-generated by the Witnet compiler, any manual changes will be overwritten except // each contracts' constructor arguments (you can freely edit those and the compiler will respect them). const Witnet = artifacts . require ( \"Witnet\" ) const WitnetBridgeInterface = artifacts . require ( \"WitnetBridgeInterface\" ) const PriceFeed = artifacts . require ( \"PriceFeed\" ) module . exports = function ( deployer ) { deployer . link ( Witnet , [ PriceFeed ]) deployer . deploy ( PriceFeed , WitnetBridgeInterface . address ) } As you can see, the autogenerated migration script is: Dynamically linking the Witnet library to your PriceFeed contract. Deploying your PriceFeed contract. Passing the address of the Witnet Bridge Interface to the PriceFeed constructor. For the compiler to pass the address of the Witnet Bridge Interface to all your consumer contracts, it is important that they have a constructor argument called _wbi , just like PriceFeed has. Customize the constructor arguments \u00b6 If your consumer contract has additional constructor arguments, the compiler will create default values for them. Before running any migration, please make sure to double-check the default arguments that the compiler inserts for you, as they may not make any sense for your specific use case. Once you modify any constructor arguments, the compiler will not rewrite those lines. If you mess them up or you want the compiler to generate default values for new constructor arguments, you can just delete those lines or remove the 3_user_contracts.js file altogether, then run the compiler once again. Run the deployment \u00b6 Deploying your contract into Truffle's own local Ethereum network is as easy as it gets: truffle migrate Please take into account that Truffle's own local network lacks any bridging capability with Witnet. This means that it is a good option for testing the migrations, but not for testing the entire workflow of your contracts. However, the Witnet community is working hard to overcome this limitation so that you can test your Witnet-connected contracts locally. If you want to test your contracts in a more realistic environment, you can deploy them into a public network using the --network flag: truffle migrate --network=rinkeby deploys on the Ethereum Rinkeby testnet. truffle migrate --network=goerli deploys on the Ethereum G\u00f6rli testnet. Deploying on mainnet is not supported yet. Take a look at the community roadmap for more information on mainnet support. Interact with your contract \u00b6 The Truffle documentation has a comprehensive guide on interacting with your contracts . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"7. Deploy"},{"location":"tutorials/bitcoin-price-feed/migrations/#7-migrate-the-contracts-into-an-ethereum-network","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"7. Migrate the contracts into an Ethereum network"},{"location":"tutorials/bitcoin-price-feed/migrations/#compile-your-solidity-contract","text":"First off, run the compile command, which compiles your Solidity contracts and recompiles the Witnet requests too: npm npm run compile yarn yarn compile","title":"Compile your Solidity contract"},{"location":"tutorials/bitcoin-price-feed/migrations/#you-got-migration-scripts-for-free","text":"Migration scripts are one of the nicest features of Truffle. They allow you to configure how your contracts will be deployed on different Ethereum networks, set your contract's constructor arguments and link dynamic dependencies. The Witnet requests compiler that lives inside the Truffle box quietly did something else than compiling your requests into Solidity contracts\u2014 it also wrote autogenerated migration scripts for your own contracts . If you look at the migrations folder, you should find these three files: 1_initial_migration.js : basic Truffle infrastructure migrations. 2_witnet_core.js : deploys all the Witnet-related contracts in case you are deploying on a local or private network; or dynamically link them if you are on a public network (Ethereum Mainnet, Rinkeby or G\u00f6rli). 3_user_contracts.js : contains autogenerated migration scripts for your consumer contracts. Let's take a look at migrations/3_user_contracts.js : // This file was auto-generated by the Witnet compiler, any manual changes will be overwritten except // each contracts' constructor arguments (you can freely edit those and the compiler will respect them). const Witnet = artifacts . require ( \"Witnet\" ) const WitnetBridgeInterface = artifacts . require ( \"WitnetBridgeInterface\" ) const PriceFeed = artifacts . require ( \"PriceFeed\" ) module . exports = function ( deployer ) { deployer . link ( Witnet , [ PriceFeed ]) deployer . deploy ( PriceFeed , WitnetBridgeInterface . address ) } As you can see, the autogenerated migration script is: Dynamically linking the Witnet library to your PriceFeed contract. Deploying your PriceFeed contract. Passing the address of the Witnet Bridge Interface to the PriceFeed constructor. For the compiler to pass the address of the Witnet Bridge Interface to all your consumer contracts, it is important that they have a constructor argument called _wbi , just like PriceFeed has.","title":"You got migration scripts, for free!"},{"location":"tutorials/bitcoin-price-feed/migrations/#customize-the-constructor-arguments","text":"If your consumer contract has additional constructor arguments, the compiler will create default values for them. Before running any migration, please make sure to double-check the default arguments that the compiler inserts for you, as they may not make any sense for your specific use case. Once you modify any constructor arguments, the compiler will not rewrite those lines. If you mess them up or you want the compiler to generate default values for new constructor arguments, you can just delete those lines or remove the 3_user_contracts.js file altogether, then run the compiler once again.","title":"Customize the constructor arguments"},{"location":"tutorials/bitcoin-price-feed/migrations/#run-the-deployment","text":"Deploying your contract into Truffle's own local Ethereum network is as easy as it gets: truffle migrate Please take into account that Truffle's own local network lacks any bridging capability with Witnet. This means that it is a good option for testing the migrations, but not for testing the entire workflow of your contracts. However, the Witnet community is working hard to overcome this limitation so that you can test your Witnet-connected contracts locally. If you want to test your contracts in a more realistic environment, you can deploy them into a public network using the --network flag: truffle migrate --network=rinkeby deploys on the Ethereum Rinkeby testnet. truffle migrate --network=goerli deploys on the Ethereum G\u00f6rli testnet. Deploying on mainnet is not supported yet. Take a look at the community roadmap for more information on mainnet support.","title":"Run the deployment"},{"location":"tutorials/bitcoin-price-feed/migrations/#interact-with-your-contract","text":"The Truffle documentation has a comprehensive guide on interacting with your contracts . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial.","title":"Interact with your contract"},{"location":"tutorials/bitcoin-price-feed/recap/","text":"Quick recap on what you built \u00b6 Congratulations! You already built your first Solidity contract using Witnet to trustlessly consume external APIs. What will you build next? Feel free to drop by the Witnet Community Discord and let us know any ideas, doubts or suggestions.","title":"Recap"},{"location":"tutorials/bitcoin-price-feed/recap/#quick-recap-on-what-you-built","text":"Congratulations! You already built your first Solidity contract using Witnet to trustlessly consume external APIs. What will you build next? Feel free to drop by the Witnet Community Discord and let us know any ideas, doubts or suggestions.","title":"Quick recap on what you built"},{"location":"tutorials/bitcoin-price-feed/sources/","text":"2. Choose and add data sources for the price feed \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. A quick intro on Witnet data sources \u00b6 Data sources are each of the endpoints from which you want Witnet to retrieve the data . Most times, these will be the URLs of public APIs. There is no limit to the number of sources in a single Witnet request\u2014although the more sources, the higher the fees will be. Each source can have a companion script that lists operations that we want the witnesses to apply on the retrieved data. This enables you to get the information of your interest extracted out of larger data structures like JSON objects. Choose your sources carefully \u00b6 Just like your friends\u2014and your enemies\u2014your data sources need to be chosen wisely . The Garbage In, Garbage Out principle really applies here. Regardless of the many checks-and-balances , well-designed incentives and security measures that the Witnet protocol implements, if the data sources in your Witnet requests are not reliable, either will your contracts be. The more data sources and the more reliable they are, the more trust-mitigated your Witnet requests will become. That is, your contracts will be more resilient to downtime, failure or corruption of each separate source. Introducing smart data sources \u00b6 The scripting language used in Witnet requests is quite rich indeed: in addition to selecting specific pieces of data, you can also transform those so they are uniform and can be compared or aggregated together. E.g. imagine a request that queries weather data. One source may use Celsius and the other may use Fahrenheit, but you will tell Witnet to transform one into another so they can be averaged. In this tutorial, you will be defining two data sources\u2014one for querying Bitstamp and the other for CoinDesk : Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number These scripts are quite self-explanatory, but there are a few details that are worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator, just as you would expect from Javascript method chaining or the builder pattern . Source scripts always start with a String 1 . Type conversions are explicit, i.e. you need to use .asString () , .asMap () , .asFloat () , etc 2 . Key-value data structures (roughly alike to Javascript objects , Python dictionaries or Solidity mappings ) are called maps . Values in maps cannot be accessed directly by name as .keyName but rather accessed through a call to the .get ( \"keyName\" ) operator. The final return type of a script is that of its last operator. For any combination of known input type and RADON script, the output type can be easily guessed upon compilation. All source scripts MUST return exactly the same type ( Float in this case). Where do I put the sources? \u00b6 Let's create a new requests/BitcoinPrice.js file and copy the two example sources above into it: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number Notice the import instruction on top, which makes possible using all the tools that the Witnet Javascript library provides: import * as Witnet from \"witnet-requests\" Please make sure you save the requests/BitcoinPrice.js file. Next step: define aggregations \u00b6 You are done with the sources for now. Let's move forward into defining aggregation and tally scripts . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial. In future versions, the Witnet protocol will make no assumptions on what the data type of the server response will be for different data sources. This will allow dealing with formats other than plain text, such as multimedia files and any other kind of binaries. Therefore, source scripts will start with Bytes as the input type and it will be totally up to the requester to specify whether those bytes should be interpreted as a String , Integer or whatnot. \u21a9 One of the key features in the future RADON 2.0 version will be implicit type casting, which will dramatically cut off the size of scripts. \u21a9","title":"2. Adding data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#2-choose-and-add-data-sources-for-the-price-feed","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"2. Choose and add data sources for the price feed"},{"location":"tutorials/bitcoin-price-feed/sources/#a-quick-intro-on-witnet-data-sources","text":"Data sources are each of the endpoints from which you want Witnet to retrieve the data . Most times, these will be the URLs of public APIs. There is no limit to the number of sources in a single Witnet request\u2014although the more sources, the higher the fees will be. Each source can have a companion script that lists operations that we want the witnesses to apply on the retrieved data. This enables you to get the information of your interest extracted out of larger data structures like JSON objects.","title":"A quick intro on Witnet data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#choose-your-sources-carefully","text":"Just like your friends\u2014and your enemies\u2014your data sources need to be chosen wisely . The Garbage In, Garbage Out principle really applies here. Regardless of the many checks-and-balances , well-designed incentives and security measures that the Witnet protocol implements, if the data sources in your Witnet requests are not reliable, either will your contracts be. The more data sources and the more reliable they are, the more trust-mitigated your Witnet requests will become. That is, your contracts will be more resilient to downtime, failure or corruption of each separate source.","title":"Choose your sources carefully"},{"location":"tutorials/bitcoin-price-feed/sources/#introducing-smart-data-sources","text":"The scripting language used in Witnet requests is quite rich indeed: in addition to selecting specific pieces of data, you can also transform those so they are uniform and can be compared or aggregated together. E.g. imagine a request that queries weather data. One source may use Celsius and the other may use Fahrenheit, but you will tell Witnet to transform one into another so they can be averaged. In this tutorial, you will be defining two data sources\u2014one for querying Bitstamp and the other for CoinDesk : Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number These scripts are quite self-explanatory, but there are a few details that are worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator, just as you would expect from Javascript method chaining or the builder pattern . Source scripts always start with a String 1 . Type conversions are explicit, i.e. you need to use .asString () , .asMap () , .asFloat () , etc 2 . Key-value data structures (roughly alike to Javascript objects , Python dictionaries or Solidity mappings ) are called maps . Values in maps cannot be accessed directly by name as .keyName but rather accessed through a call to the .get ( \"keyName\" ) operator. The final return type of a script is that of its last operator. For any combination of known input type and RADON script, the output type can be easily guessed upon compilation. All source scripts MUST return exactly the same type ( Float in this case).","title":"Introducing smart data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#where-do-i-put-the-sources","text":"Let's create a new requests/BitcoinPrice.js file and copy the two example sources above into it: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `bpi` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `USD` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `rate_float` key . asFloat () // Treat that as a floating point number Notice the import instruction on top, which makes possible using all the tools that the Witnet Javascript library provides: import * as Witnet from \"witnet-requests\" Please make sure you save the requests/BitcoinPrice.js file.","title":"Where do I put the sources?"},{"location":"tutorials/bitcoin-price-feed/sources/#next-step-define-aggregations","text":"You are done with the sources for now. Let's move forward into defining aggregation and tally scripts . Remember: You are not alone! You are invited to join the Witnet Community Discord . Members of the Witnet community will be happy to answer your questions and doubts, as well as assisting you through this tutorial. In future versions, the Witnet protocol will make no assumptions on what the data type of the server response will be for different data sources. This will allow dealing with formats other than plain text, such as multimedia files and any other kind of binaries. Therefore, source scripts will start with Bytes as the input type and it will be totally up to the requester to specify whether those bytes should be interpreted as a String , Integer or whatnot. \u21a9 One of the key features in the future RADON 2.0 version will be implicit type casting, which will dramatically cut off the size of scripts. \u21a9","title":"Next step: define aggregations"}]}