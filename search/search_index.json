{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Witnet ecosystem! \u00b6 The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information on behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which incentivizes network players to abide by the protocol and makes them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum . Node operators, a.k.a. Witnesses \u00b6 The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts. Developers \u00b6 The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet . Contribute to Witnet-Rust or Sheikah . Witnet Foundation \u00b6 The Witnet Foundation is the independent entity currently in charge of funding the development of Witnet-Rust and Sheikah, as well as nurturing an engaged and diverse ecosystem around the Witnet protocol. Other stakeholders \u00b6 The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many ways to get involved !","title":"Ecosystem"},{"location":"#welcome-to-the-witnet-ecosystem","text":"The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information on behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which incentivizes network players to abide by the protocol and makes them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum .","title":"Welcome to the Witnet ecosystem!"},{"location":"#node-operators-aka-witnesses","text":"The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts.","title":"Node operators, a.k.a. Witnesses"},{"location":"#developers","text":"The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet . Contribute to Witnet-Rust or Sheikah .","title":"Developers"},{"location":"#witnet-foundation","text":"The Witnet Foundation is the independent entity currently in charge of funding the development of Witnet-Rust and Sheikah, as well as nurturing an engaged and diverse ecosystem around the Witnet protocol.","title":"Witnet Foundation"},{"location":"#other-stakeholders","text":"The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many ways to get involved !","title":"Other stakeholders"},{"location":"community/roadmap/","text":"Community Roadmap \u00b6 Witnet is an open initiative and Witnet-Rust and Sheikah are open source projects that are under development by an open community of organizations and independent developers. This means that no one can set the roadmap unilaterally. During the pre-mainnet phase, a subsequent testnet release is expected every to months, and each of them is a hard fork and full reset of the chain: [ Testnet-1 ] Jan 2019: basic protocol capabilities [ Testnet-2 ] Mar 2019: security and scalability improvements [ Testnet-3 ] May 2019: algorithmic reputation system [ Testnet-4 ] Jul 2019: Ethereum bridge [ Testnet-5 ] Sep 2019: mainnet readiness Given the experimental nature of the technologies and network protocols under development, these dates and deliverables may be subject to change due to reasons beyond the control of Witnet Foundation.","title":"Roadmap"},{"location":"community/roadmap/#community-roadmap","text":"Witnet is an open initiative and Witnet-Rust and Sheikah are open source projects that are under development by an open community of organizations and independent developers. This means that no one can set the roadmap unilaterally. During the pre-mainnet phase, a subsequent testnet release is expected every to months, and each of them is a hard fork and full reset of the chain: [ Testnet-1 ] Jan 2019: basic protocol capabilities [ Testnet-2 ] Mar 2019: security and scalability improvements [ Testnet-3 ] May 2019: algorithmic reputation system [ Testnet-4 ] Jul 2019: Ethereum bridge [ Testnet-5 ] Sep 2019: mainnet readiness Given the experimental nature of the technologies and network protocols under development, these dates and deliverables may be subject to change due to reasons beyond the control of Witnet Foundation.","title":"Community Roadmap"},{"location":"developer/contributing/","text":"Contributing to Witnet \u00b6 Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document. Code of conduct \u00b6 Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well. I just have a question \u00b6 Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response. How can I contribute? \u00b6 Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma. Reporting bugs \u00b6 This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having. How do I submit a good bug report? \u00b6 Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version? Suggesting enhancements \u00b6 This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible. How Do I Submit A Good Enhancement Suggestion? \u00b6 Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package. Your First Code Contribution \u00b6 Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two. Sending a Pull Request \u00b6 Commit messages convention \u00b6 We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat ( mining ): use a random nonce as input in mint transactions BREAKING CHANGE : former mint transactions containing no inputs will be rendered invalid refactor ( config ): make `config` actor return settings as `Option` s docs : add RADON `FLOAT_TOSTRING` opcode this operator converts any floating point number into a UTF8 string chore ( cargo ): upgrade `actix` to version 0 . 8 . 1 fix #503 PGP-signing your commits \u00b6 All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"Contributing"},{"location":"developer/contributing/#contributing-to-witnet","text":"Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document.","title":"Contributing to Witnet"},{"location":"developer/contributing/#code-of-conduct","text":"Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well.","title":"Code of conduct"},{"location":"developer/contributing/#i-just-have-a-question","text":"Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response.","title":"I just have a question"},{"location":"developer/contributing/#how-can-i-contribute","text":"Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma.","title":"How can I contribute?"},{"location":"developer/contributing/#reporting-bugs","text":"This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having.","title":"Reporting bugs"},{"location":"developer/contributing/#how-do-i-submit-a-good-bug-report","text":"Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version?","title":"How do I submit a good bug report?"},{"location":"developer/contributing/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible.","title":"Suggesting enhancements"},{"location":"developer/contributing/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package.","title":"How Do I Submit A Good Enhancement Suggestion?"},{"location":"developer/contributing/#your-first-code-contribution","text":"Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two.","title":"Your First Code Contribution"},{"location":"developer/contributing/#sending-a-pull-request","text":"","title":"Sending a Pull Request"},{"location":"developer/contributing/#commit-messages-convention","text":"We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat ( mining ): use a random nonce as input in mint transactions BREAKING CHANGE : former mint transactions containing no inputs will be rendered invalid refactor ( config ): make `config` actor return settings as `Option` s docs : add RADON `FLOAT_TOSTRING` opcode this operator converts any floating point number into a UTF8 string chore ( cargo ): upgrade `actix` to version 0 . 8 . 1 fix #503","title":"Commit messages convention"},{"location":"developer/contributing/#pgp-signing-your-commits","text":"All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"PGP-signing your commits"},{"location":"developer/from-source/","text":"Running witnet-rust from source code \u00b6 Install compilation dependencies \u00b6 Rust \u00b6 witnet-rust is being developed using the Rust programming language. You need to install Rust on your system to be able to compile the source code. Follow installation instructions for your operating system provided on rustup.rs Compilation dependencies \u00b6 GNU/Linux (apt) apt install -y clang git libssl-dev protobuf-compiler librocksdb-dev pkg-config macOS xcode-select --install brew install git openssl protobuf rocksdb Clone source code from Witnet GitHub repository \u00b6 HTTPS git clone https://github.com/witnet/witnet-rust.git cd witnet-rust Get the latest genesis_block.json \u00b6 curl https://raw.githubusercontent.com/witnet/genesis_block/master/latest/genesis_block.json -o genesis_block.json Compile and run with cargo \u00b6 By default, this line will run a Witnet node and connect to the Testnet using the default configuration: cargo run node server For more witnet-rust commands you can read the witnet-rust CLI documentation . Building a release \u00b6 This one-liner will build a releasable standalone binary compatible with the architecture of your computer's processor: cargo build --release The resulting binary will be located at ./target/release/witnet .","title":"Compile from source code"},{"location":"developer/from-source/#running-witnet-rust-from-source-code","text":"","title":"Running witnet-rust from source code"},{"location":"developer/from-source/#install-compilation-dependencies","text":"","title":"Install compilation dependencies"},{"location":"developer/from-source/#rust","text":"witnet-rust is being developed using the Rust programming language. You need to install Rust on your system to be able to compile the source code. Follow installation instructions for your operating system provided on rustup.rs","title":"Rust"},{"location":"developer/from-source/#compilation-dependencies","text":"GNU/Linux (apt) apt install -y clang git libssl-dev protobuf-compiler librocksdb-dev pkg-config macOS xcode-select --install brew install git openssl protobuf rocksdb","title":"Compilation dependencies"},{"location":"developer/from-source/#clone-source-code-from-witnet-github-repository","text":"HTTPS git clone https://github.com/witnet/witnet-rust.git cd witnet-rust","title":"Clone source code from Witnet GitHub repository"},{"location":"developer/from-source/#get-the-latest-genesis_blockjson","text":"curl https://raw.githubusercontent.com/witnet/genesis_block/master/latest/genesis_block.json -o genesis_block.json","title":"Get the latest genesis_block.json"},{"location":"developer/from-source/#compile-and-run-with-cargo","text":"By default, this line will run a Witnet node and connect to the Testnet using the default configuration: cargo run node server For more witnet-rust commands you can read the witnet-rust CLI documentation .","title":"Compile and run with cargo"},{"location":"developer/from-source/#building-a-release","text":"This one-liner will build a releasable standalone binary compatible with the architecture of your computer's processor: cargo build --release The resulting binary will be located at ./target/release/witnet .","title":"Building a release"},{"location":"node-operators/cli/","text":"Command Line Interface (CLI) \u00b6 The cli subcommand provides a human-friendly command-line interface to the node JSON-RPC API . Usage \u00b6 See all the available options by running the help command using docker, binary or cargo. Docker docker exec witnet_node witnet node --help Binary witnet node --help Cargo cargo run -- node --help To get more information about any specific command, simply add --help at the end. For instance, this will show the available options for the blockchain command: Docker docker exec witnet_node witnet node blockchain --help Binary witnet node blockchain --help Cargo cargo run -- node blockchain --help The JSON-RPC server address is obtained from the configuration file . The path of this file can be set using the -c or --config flag. This flag must appear before node . Docker docker exec witnet_node witnet node -c witnet.toml node blockchain Binary witnet -c witnet.toml node blockchain Cargo cargo run -- -c witnet.toml node blockchain You can use the -n flag to easily overwrite the node address. This flag must appear after the command name. Docker docker exec witnet_node witnet node -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Binary witnet -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Cargo cargo run -- -c witnet.toml node blockchain -n \"127.0.0.1:1234\" If there is any error, the process will return a non-zero exit code. Docker docker exec witnet_node witnet node node blockchain Error: Connection refused (os error 111) Binary witnet node blockchain Error: Connection refused (os error 111) Cargo cargo run -- node blockchain Error: Connection refused (os error 111) The executable implements the usual logging API, which can be enabled using RUST_LOG=witnet=debug : Docker $ docker exec witnet_node witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Binary $ RUST_LOG=witnet=debug witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Cargo $ RUST_LOG=witnet=debug cargo run -- node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Commands \u00b6 address \u00b6 Get the identifier of the node that acts as its address when interacting with the protocol through transactions. This is the address used for mining blocks, resolving data requests, and receiving value transfer transactions. Docker docker exec witnet_node witnet node address Binary witnet node address Cargo cargo run -- node address Example output: twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr balance \u00b6 Get total balance of a given Witnet address. Balances are shown in wits. --address=address : address for which to get balance. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node balance docker exec witnet_node witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Binary witnet node balance witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Cargo cargo run -- node balance cargo run -- node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: 34099.999950005 wits block \u00b6 Print out detailed information about a block being queried by its hash. Docker docker exec witnet_node witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Binary witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Cargo cargo run -- node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 The hash of the block should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"block_header\" :{ \"beacon\" :{ \"checkpoint\" : 74005 , \"hashPrevBlock\" : \"ac6ec0020e726577fa3df3fd04de2a30b020c4a864602375a129e090707a90dc\" }, \"merkle_roots\" :{ \"commit_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"dr_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"mint_hash\" : \"a02e6038ec2a472d6daa8f374bdeca84a62cd5731d33dd865f497f34360874ef\" , \"reveal_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"tally_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"vt_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" }, \"proof\" :{ \"proof\" :{ \"proof\" :[ 2 , 76 , 213 , 68 , 242 , 86 , 29 , 133 , 44 , 102 , 231 , 220 , 74 , 198 , 196 , 117 , 106 , 87 , 200 , 168 , 77 , 176 , 129 , 130 , 10 , 164 , 24 , 13 , 131 , 141 , 240 , 28 , 46 , 72 , 247 , 80 , 196 , 178 , 67 , 144 , 46 , 246 , 44 , 191 , 20 , 119 , 187 , 160 , 110 , 73 , 60 , 243 , 160 , 231 , 188 , 124 , 69 , 238 , 130 , 148 , 69 , 137 , 102 , 60 , 56 , 33 , 62 , 127 , 90 , 62 , 47 , 62 , 77 , 79 , 163 , 151 , 49 , 233 , 127 , 65 , 103 ], \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }}}, \"version\" : 0 }, \"block_sig\" :{ \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 13 , 144 , 153 , 43 , 104 , 8 , 14 , 205 , 157 , 88 , 181 , 226 , 110 , 189 , 101 , 148 , 248 , 193 , 170 , 99 , 177 , 219 , 228 , 149 , 239 , 34 , 1 , 245 , 13 , 207 , 123 , 220 , 2 , 32 , 108 , 71 , 130 , 109 , 147 , 73 , 92 , 96 , 149 , 102 , 125 , 144 , 146 , 252 , 143 , 66 , 74 , 105 , 52 , 185 , 196 , 217 , 95 , 249 , 157 , 11 , 108 , 254 , 35 , 187 , 67 , 12 ]}}}, \"txns\" :{ \"commit_txns\" :[], \"data_request_txns\" :[], \"mint\" :{ \"epoch\" : 74005 , \"output\" :{ \"pkh\" : \"twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr\" , \"time_lock\" : 0 , \"value\" : 50000000000 }}, \"reveal_txns\" :[], \"tally_txns\" :[], \"value_transfer_txns\" :[]}}, \"id\" : \"1\" } blockchain \u00b6 List block hashes in the local block chain, matched with their epochs. Docker docker exec witnet_node witnet node blockchain Binary witnet node blockchain Cargo cargo --run node blockchain This method accepts two optional arguments: --epoch=n : the first epoch for which to show block hashes. A negative epoch means \"n epochs ago\". --limit=n : the number of epochs. If zero, unlimited. Docker # Get all the block hashes from the genesis block docker exec witnet_node witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] docker exec witnet_node witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs docker exec witnet_node witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago docker exec witnet_node witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block docker exec witnet_node witnet node blockchain --epoch=-1 --limit=1 Binary # Get all the block hashes from the genesis block witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block witnet node blockchain --epoch=-1 --limit=1 Cargo # Get all the block hashes from the genesis block cargo run -- node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] cargo run -- node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs cargo run -- node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago cargo run -- node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block cargo run -- node blockchain --epoch=-1 --limit=1 Example output: block for epoch #76229 had digest 8dd75bb0d5475a93c27c4166677fbb3bc154e6731c7e07ecad549a58851c84a4 dataRequestReport \u00b6 Show information about a data request. Docker docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Example output: Report for data request 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d: Deployed in block 159045c67d97e284588be4da89a43319735919144b2aaf1468e7eae6682f42b6 by twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl FINISHED with 2 commits and 2 reveals Commit rounds: 1/2 Reveal rounds: 1/2 Reveals: [Rewarded ] twit1xpc5d7dz6rsnnjrlp98vtn496qzrawu7y5cyx4: RadonTypes::RadonFloat(10172.642950000001) [Rewarded ] twit1xcnfm3q57h7uh7y2m23y6hd7jsqufyrlmxgfnq: RadonTypes::RadonFloat(10172.642950000001) Tally: RadonTypes::RadonFloat(10172.642950000001) If you want to see the request move forwards through its different stages in real time you can use the watch command while it is being resolved: Docker watch --color docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary watch --color witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo watch --color cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d joinTransaction \u00b6 Create a value transfer transaction that joins UTXOs. The following arguments must be provided. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --fee=1 Binary witnet node joinTransaction --value=100 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --fee=1 knownPeers \u00b6 Get the list of peer addresses known to the node. These addresses are tagged as: Docker docker exec witnet_node witnet node knownPeers Binary witnet node knownPeers Cargo cargo run -- node knownPeers masterKeyExport \u00b6 Export the node's master private key. Please keep this totally secret. Anyone with knowledge of this key has full access to all your wit tokens. Docker docker exec witnet_node witnet node masterKeyExport Binary witnet node masterkeyExport Cargo cargo run -- node masterkeyExport nodeStats \u00b6 Display local node stats. Docker docker exec witnet_node witnet node nodeStats Cargo cargo run -- node nodeStats Binary witnet node nodeStats Among other information, this shows counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"): Block mining stats Proposed blocks Blocks included in the block chain Data Request mining stats: Times with eligibility to mine a data request Proposed commits Accepted commits Slashed commits Example output: Block mining stats: - Proposed blocks: 81 - Blocks included in the block chain: 1 Data Request mining stats: - Times with eligibility to mine a data request: 2 - Proposed commits: 0 - Accepted commits: 0 - Slashed commits: 0 Tip Note that it is perfectly normal for a node to show 0 \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. output \u00b6 Display a transaction output, as referred by it's \"output pointer\", that is, <transaction_id>:<output_index> . Docker docker exec witnet_node witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d:0 Binary witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d peers \u00b6 List inbound and outbound connections currently established by the node. Outbound connections are those initiated on our side, and inbound connections are those that were initiated by peer nodes. A node that does not announce a public address (IP and port) will normally have no inbound connections, as there is no way for other nodes to discover a valid network route to it. Docker docker exec witnet_node witnet node peers Binary witnet node peers Cargo cargo run -- node peers raw \u00b6 The raw command allows sending raw JSON-RPC requests from the command line. It can be used in an interactive way (don't forget the -i flag when using Docker): each line of user input will be sent to the JSON-RPC server without any modifications: Docker $ docker exec -i witnet_node witnet node raw Binary $ witnet -c witnet.toml node raw Cargo $ cargo run -- -c witnet.toml node raw Each block represents a method call: the first line is a request, the second line is a response. hi { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } { \"jsonrpc\" : \"2.0\" , \"method\" : \"blockChain\" , \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"result\" : [[ 242037 , \"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\" ]], \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"method\" : \"someInvalidMethod\" , \"id\" : 2 } { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32601 , \"message\" : \"Method not found\" }, \"id\" : 2 } bye { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } Alternatively, the input can be read from a file using pipes, as is usual in Unix-like environments. For instance, the bitcoin_price.json data request example from the witnet-rust reposity can be easily deployed into the network using the raw command like this: Docker cat examples/bitcoin_price.json | docker exec -i witnet_node witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Binary cat examples/bitcoin_price.json | witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Cargo cat examples/bitcoin_price.json | cargo run -- node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} reputation \u00b6 Displays the reputation score associated with a given Witnet address. --address=address : address for which to get reputation score. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node reputation docker exec witnet_node witnet node reputation --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Binary witnet node reputation witnet node reputation --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Cargo cargo run -- node reputation cargo run -- node reputation --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: Identity twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr has 1 reputation and is active Adding the flag --all flag lists all the nodes having non-zero reputation. Tip Note that it is perfectly normal for a node to show 0 reputation for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. Docker docker exec witnet_node witnet node reputation --all Binary witnet node reputation --all Cargo cargo run -- node reputation --all Example output: Total Reputation : { [ A ] twit1t99a5r6d0lqstl8rdkqw3ywfs2y4zwqhy5zprt : 1 [ A ] twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr : 1 } send \u00b6 Create and broadcast a value transfer transaction. That is, send some amount of wit tokens from the node's own balance into a different Witnet address. --address=address : recipient address. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. --time-lock=timestamp : optional time lock for the created output: the receiver will not be able to spend the output until the timestamp is reached. 0 means no time-lock. On success, returns the transaction hash: Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} On error, returns the error message: Docker docker exec witnet_node witnet node send --address = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Binary witnet node send --address = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Cargo cargo run -- node send --address = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Example with time lock set to 2019-10-01 Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} sendRequest \u00b6 Send a serialized data request. An example of how to create such a request can be found in the tutorial . Docker docker exec witnet_node witnet node sendRequest --hex \"data request output serialized in hexadecimal format\" Cargo cargo run -- node sendRequest --hex \"data request output serialized in hexadecimal format\" Binary witnet node sendRequest --hex \"data request output serialized in hexadecimal format\" server \u00b6 Run a Witnet node server. Docker docker exec witnet_node witnet node server Binary witnet node server Cargo cargo run -- node server splitTransaction \u00b6 Create a value transfer transaction that splits UTXOs. The following arguments must be provided: --value=amount : amount in nanoWits. --size=size :amount in nanoWits of each UTXO. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --size=3 --fee=1 Binary witnet node joinTransaction --value=100 --size=3 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --size=3 --fee=1 transaction \u00b6 Print out detailed information about a transaction being queried by its hash. Docker docker exec witnet_node witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Binary witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Cargo cargo run -- node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 The hash of the transaction should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"blockHash\" : \"0c29023ec3c8c9e1a51871a67e235168315160d9f757737c2c390f0a35ad1b24\" , \"transaction\" :{ \"ValueTransfer\" :{ \"body\" :{ \"inputs\" :[{ \"output_pointer\" : \"126549b3ea96f40bb211660d7991109d72b43e68e846ea76d4d2f6cd5a3cc7ff:1\" }], \"outputs\" :[{ \"pkh\" : \"twit12nqlkyp0zfhthfz898tplh3ns7nedcvlezx4r4\" , \"time_lock\" : 0 , \"value\" : 100 },{ \"pkh\" : \"twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl\" , \"time_lock\" : 0 , \"value\" : 499999999987 }]}, \"signatures\" :[{ \"public_key\" :{ \"bytes\" :[ 109 , 158 , 138 , 247 , 58 , 8 , 183 , 138 , 57 , 113 , 147 , 147 , 136 , 177 , 252 , 244 , 33 , 147 , 143 , 200 , 255 , 89 , 208 , 192 , 214 , 81 , 128 , 224 , 219 , 180 , 136 , 155 ], \"compressed\" : 3 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 25 , 163 , 14 , 139 , 5 , 92 , 35 , 157 , 90 , 73 , 162 , 93 , 88 , 67 , 117 , 152 , 104 , 178 , 208 , 225 , 123 , 131 , 236 , 59 , 240 , 136 , 18 , 55 , 79 , 168 , 12 , 218 , 2 , 32 , 76 , 68 , 59 , 125 , 99 , 133 , 74 , 11 , 232 , 70 , 157 , 116 , 68 , 151 , 70 , 39 , 187 , 132 , 190 , 110 , 245 , 214 , 29 , 179 , 198 , 182 , 24 , 133 , 137 , 177 , 187 , 142 ]}}}]}}}, \"id\" : \"1\" } utxos \u00b6 Get the unspent transaction outputs of the node. This shows how many UTXOs are available for your node to spend or collateralize. Docker docker exec witnet_node witnet node utxos Binary witnet node utxos Cargo cargo run -- node utxos The output includes information about: Total number of utxos Total number of utxos bigger than collateral minimum Total number of utxos older than collateral coinage The flag --long can be added to the command to get a detailed list of the UTXOs and whether each of them is spendable or collateralizable at this time.","title":"Command Line Interface"},{"location":"node-operators/cli/#command-line-interface-cli","text":"The cli subcommand provides a human-friendly command-line interface to the node JSON-RPC API .","title":"Command Line Interface (CLI)"},{"location":"node-operators/cli/#usage","text":"See all the available options by running the help command using docker, binary or cargo. Docker docker exec witnet_node witnet node --help Binary witnet node --help Cargo cargo run -- node --help To get more information about any specific command, simply add --help at the end. For instance, this will show the available options for the blockchain command: Docker docker exec witnet_node witnet node blockchain --help Binary witnet node blockchain --help Cargo cargo run -- node blockchain --help The JSON-RPC server address is obtained from the configuration file . The path of this file can be set using the -c or --config flag. This flag must appear before node . Docker docker exec witnet_node witnet node -c witnet.toml node blockchain Binary witnet -c witnet.toml node blockchain Cargo cargo run -- -c witnet.toml node blockchain You can use the -n flag to easily overwrite the node address. This flag must appear after the command name. Docker docker exec witnet_node witnet node -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Binary witnet -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Cargo cargo run -- -c witnet.toml node blockchain -n \"127.0.0.1:1234\" If there is any error, the process will return a non-zero exit code. Docker docker exec witnet_node witnet node node blockchain Error: Connection refused (os error 111) Binary witnet node blockchain Error: Connection refused (os error 111) Cargo cargo run -- node blockchain Error: Connection refused (os error 111) The executable implements the usual logging API, which can be enabled using RUST_LOG=witnet=debug : Docker $ docker exec witnet_node witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Binary $ RUST_LOG=witnet=debug witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Cargo $ RUST_LOG=witnet=debug cargo run -- node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111)","title":"Usage"},{"location":"node-operators/cli/#commands","text":"","title":"Commands"},{"location":"node-operators/cli/#address","text":"Get the identifier of the node that acts as its address when interacting with the protocol through transactions. This is the address used for mining blocks, resolving data requests, and receiving value transfer transactions. Docker docker exec witnet_node witnet node address Binary witnet node address Cargo cargo run -- node address Example output: twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr","title":"address"},{"location":"node-operators/cli/#balance","text":"Get total balance of a given Witnet address. Balances are shown in wits. --address=address : address for which to get balance. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node balance docker exec witnet_node witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Binary witnet node balance witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Cargo cargo run -- node balance cargo run -- node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: 34099.999950005 wits","title":"balance"},{"location":"node-operators/cli/#block","text":"Print out detailed information about a block being queried by its hash. Docker docker exec witnet_node witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Binary witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Cargo cargo run -- node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 The hash of the block should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"block_header\" :{ \"beacon\" :{ \"checkpoint\" : 74005 , \"hashPrevBlock\" : \"ac6ec0020e726577fa3df3fd04de2a30b020c4a864602375a129e090707a90dc\" }, \"merkle_roots\" :{ \"commit_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"dr_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"mint_hash\" : \"a02e6038ec2a472d6daa8f374bdeca84a62cd5731d33dd865f497f34360874ef\" , \"reveal_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"tally_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"vt_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" }, \"proof\" :{ \"proof\" :{ \"proof\" :[ 2 , 76 , 213 , 68 , 242 , 86 , 29 , 133 , 44 , 102 , 231 , 220 , 74 , 198 , 196 , 117 , 106 , 87 , 200 , 168 , 77 , 176 , 129 , 130 , 10 , 164 , 24 , 13 , 131 , 141 , 240 , 28 , 46 , 72 , 247 , 80 , 196 , 178 , 67 , 144 , 46 , 246 , 44 , 191 , 20 , 119 , 187 , 160 , 110 , 73 , 60 , 243 , 160 , 231 , 188 , 124 , 69 , 238 , 130 , 148 , 69 , 137 , 102 , 60 , 56 , 33 , 62 , 127 , 90 , 62 , 47 , 62 , 77 , 79 , 163 , 151 , 49 , 233 , 127 , 65 , 103 ], \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }}}, \"version\" : 0 }, \"block_sig\" :{ \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 13 , 144 , 153 , 43 , 104 , 8 , 14 , 205 , 157 , 88 , 181 , 226 , 110 , 189 , 101 , 148 , 248 , 193 , 170 , 99 , 177 , 219 , 228 , 149 , 239 , 34 , 1 , 245 , 13 , 207 , 123 , 220 , 2 , 32 , 108 , 71 , 130 , 109 , 147 , 73 , 92 , 96 , 149 , 102 , 125 , 144 , 146 , 252 , 143 , 66 , 74 , 105 , 52 , 185 , 196 , 217 , 95 , 249 , 157 , 11 , 108 , 254 , 35 , 187 , 67 , 12 ]}}}, \"txns\" :{ \"commit_txns\" :[], \"data_request_txns\" :[], \"mint\" :{ \"epoch\" : 74005 , \"output\" :{ \"pkh\" : \"twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr\" , \"time_lock\" : 0 , \"value\" : 50000000000 }}, \"reveal_txns\" :[], \"tally_txns\" :[], \"value_transfer_txns\" :[]}}, \"id\" : \"1\" }","title":"block"},{"location":"node-operators/cli/#blockchain","text":"List block hashes in the local block chain, matched with their epochs. Docker docker exec witnet_node witnet node blockchain Binary witnet node blockchain Cargo cargo --run node blockchain This method accepts two optional arguments: --epoch=n : the first epoch for which to show block hashes. A negative epoch means \"n epochs ago\". --limit=n : the number of epochs. If zero, unlimited. Docker # Get all the block hashes from the genesis block docker exec witnet_node witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] docker exec witnet_node witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs docker exec witnet_node witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago docker exec witnet_node witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block docker exec witnet_node witnet node blockchain --epoch=-1 --limit=1 Binary # Get all the block hashes from the genesis block witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block witnet node blockchain --epoch=-1 --limit=1 Cargo # Get all the block hashes from the genesis block cargo run -- node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] cargo run -- node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs cargo run -- node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago cargo run -- node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block cargo run -- node blockchain --epoch=-1 --limit=1 Example output: block for epoch #76229 had digest 8dd75bb0d5475a93c27c4166677fbb3bc154e6731c7e07ecad549a58851c84a4","title":"blockchain"},{"location":"node-operators/cli/#datarequestreport","text":"Show information about a data request. Docker docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Example output: Report for data request 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d: Deployed in block 159045c67d97e284588be4da89a43319735919144b2aaf1468e7eae6682f42b6 by twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl FINISHED with 2 commits and 2 reveals Commit rounds: 1/2 Reveal rounds: 1/2 Reveals: [Rewarded ] twit1xpc5d7dz6rsnnjrlp98vtn496qzrawu7y5cyx4: RadonTypes::RadonFloat(10172.642950000001) [Rewarded ] twit1xcnfm3q57h7uh7y2m23y6hd7jsqufyrlmxgfnq: RadonTypes::RadonFloat(10172.642950000001) Tally: RadonTypes::RadonFloat(10172.642950000001) If you want to see the request move forwards through its different stages in real time you can use the watch command while it is being resolved: Docker watch --color docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary watch --color witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo watch --color cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d","title":"dataRequestReport"},{"location":"node-operators/cli/#jointransaction","text":"Create a value transfer transaction that joins UTXOs. The following arguments must be provided. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --fee=1 Binary witnet node joinTransaction --value=100 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --fee=1","title":"joinTransaction"},{"location":"node-operators/cli/#knownpeers","text":"Get the list of peer addresses known to the node. These addresses are tagged as: Docker docker exec witnet_node witnet node knownPeers Binary witnet node knownPeers Cargo cargo run -- node knownPeers","title":"knownPeers"},{"location":"node-operators/cli/#masterkeyexport","text":"Export the node's master private key. Please keep this totally secret. Anyone with knowledge of this key has full access to all your wit tokens. Docker docker exec witnet_node witnet node masterKeyExport Binary witnet node masterkeyExport Cargo cargo run -- node masterkeyExport","title":"masterKeyExport"},{"location":"node-operators/cli/#nodestats","text":"Display local node stats. Docker docker exec witnet_node witnet node nodeStats Cargo cargo run -- node nodeStats Binary witnet node nodeStats Among other information, this shows counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"): Block mining stats Proposed blocks Blocks included in the block chain Data Request mining stats: Times with eligibility to mine a data request Proposed commits Accepted commits Slashed commits Example output: Block mining stats: - Proposed blocks: 81 - Blocks included in the block chain: 1 Data Request mining stats: - Times with eligibility to mine a data request: 2 - Proposed commits: 0 - Accepted commits: 0 - Slashed commits: 0 Tip Note that it is perfectly normal for a node to show 0 \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons.","title":"nodeStats"},{"location":"node-operators/cli/#output","text":"Display a transaction output, as referred by it's \"output pointer\", that is, <transaction_id>:<output_index> . Docker docker exec witnet_node witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d:0 Binary witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d","title":"output"},{"location":"node-operators/cli/#peers","text":"List inbound and outbound connections currently established by the node. Outbound connections are those initiated on our side, and inbound connections are those that were initiated by peer nodes. A node that does not announce a public address (IP and port) will normally have no inbound connections, as there is no way for other nodes to discover a valid network route to it. Docker docker exec witnet_node witnet node peers Binary witnet node peers Cargo cargo run -- node peers","title":"peers"},{"location":"node-operators/cli/#raw","text":"The raw command allows sending raw JSON-RPC requests from the command line. It can be used in an interactive way (don't forget the -i flag when using Docker): each line of user input will be sent to the JSON-RPC server without any modifications: Docker $ docker exec -i witnet_node witnet node raw Binary $ witnet -c witnet.toml node raw Cargo $ cargo run -- -c witnet.toml node raw Each block represents a method call: the first line is a request, the second line is a response. hi { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } { \"jsonrpc\" : \"2.0\" , \"method\" : \"blockChain\" , \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"result\" : [[ 242037 , \"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\" ]], \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"method\" : \"someInvalidMethod\" , \"id\" : 2 } { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32601 , \"message\" : \"Method not found\" }, \"id\" : 2 } bye { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } Alternatively, the input can be read from a file using pipes, as is usual in Unix-like environments. For instance, the bitcoin_price.json data request example from the witnet-rust reposity can be easily deployed into the network using the raw command like this: Docker cat examples/bitcoin_price.json | docker exec -i witnet_node witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Binary cat examples/bitcoin_price.json | witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Cargo cat examples/bitcoin_price.json | cargo run -- node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"}","title":"raw"},{"location":"node-operators/cli/#reputation","text":"Displays the reputation score associated with a given Witnet address. --address=address : address for which to get reputation score. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node reputation docker exec witnet_node witnet node reputation --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Binary witnet node reputation witnet node reputation --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Cargo cargo run -- node reputation cargo run -- node reputation --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: Identity twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr has 1 reputation and is active Adding the flag --all flag lists all the nodes having non-zero reputation. Tip Note that it is perfectly normal for a node to show 0 reputation for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. Docker docker exec witnet_node witnet node reputation --all Binary witnet node reputation --all Cargo cargo run -- node reputation --all Example output: Total Reputation : { [ A ] twit1t99a5r6d0lqstl8rdkqw3ywfs2y4zwqhy5zprt : 1 [ A ] twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr : 1 }","title":"reputation"},{"location":"node-operators/cli/#send","text":"Create and broadcast a value transfer transaction. That is, send some amount of wit tokens from the node's own balance into a different Witnet address. --address=address : recipient address. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. --time-lock=timestamp : optional time lock for the created output: the receiver will not be able to spend the output until the timestamp is reached. 0 means no time-lock. On success, returns the transaction hash: Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} On error, returns the error message: Docker docker exec witnet_node witnet node send --address = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Binary witnet node send --address = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Cargo cargo run -- node send --address = twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value = 9999999999999999999 --fee = 1 { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32603 , \"message\" : \"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\" }, \"id\" : \"1\" } Example with time lock set to 2019-10-01 Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"}","title":"send"},{"location":"node-operators/cli/#sendrequest","text":"Send a serialized data request. An example of how to create such a request can be found in the tutorial . Docker docker exec witnet_node witnet node sendRequest --hex \"data request output serialized in hexadecimal format\" Cargo cargo run -- node sendRequest --hex \"data request output serialized in hexadecimal format\" Binary witnet node sendRequest --hex \"data request output serialized in hexadecimal format\"","title":"sendRequest"},{"location":"node-operators/cli/#server","text":"Run a Witnet node server. Docker docker exec witnet_node witnet node server Binary witnet node server Cargo cargo run -- node server","title":"server"},{"location":"node-operators/cli/#splittransaction","text":"Create a value transfer transaction that splits UTXOs. The following arguments must be provided: --value=amount : amount in nanoWits. --size=size :amount in nanoWits of each UTXO. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --size=3 --fee=1 Binary witnet node joinTransaction --value=100 --size=3 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --size=3 --fee=1","title":"splitTransaction"},{"location":"node-operators/cli/#transaction","text":"Print out detailed information about a transaction being queried by its hash. Docker docker exec witnet_node witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Binary witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Cargo cargo run -- node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 The hash of the transaction should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"blockHash\" : \"0c29023ec3c8c9e1a51871a67e235168315160d9f757737c2c390f0a35ad1b24\" , \"transaction\" :{ \"ValueTransfer\" :{ \"body\" :{ \"inputs\" :[{ \"output_pointer\" : \"126549b3ea96f40bb211660d7991109d72b43e68e846ea76d4d2f6cd5a3cc7ff:1\" }], \"outputs\" :[{ \"pkh\" : \"twit12nqlkyp0zfhthfz898tplh3ns7nedcvlezx4r4\" , \"time_lock\" : 0 , \"value\" : 100 },{ \"pkh\" : \"twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl\" , \"time_lock\" : 0 , \"value\" : 499999999987 }]}, \"signatures\" :[{ \"public_key\" :{ \"bytes\" :[ 109 , 158 , 138 , 247 , 58 , 8 , 183 , 138 , 57 , 113 , 147 , 147 , 136 , 177 , 252 , 244 , 33 , 147 , 143 , 200 , 255 , 89 , 208 , 192 , 214 , 81 , 128 , 224 , 219 , 180 , 136 , 155 ], \"compressed\" : 3 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 25 , 163 , 14 , 139 , 5 , 92 , 35 , 157 , 90 , 73 , 162 , 93 , 88 , 67 , 117 , 152 , 104 , 178 , 208 , 225 , 123 , 131 , 236 , 59 , 240 , 136 , 18 , 55 , 79 , 168 , 12 , 218 , 2 , 32 , 76 , 68 , 59 , 125 , 99 , 133 , 74 , 11 , 232 , 70 , 157 , 116 , 68 , 151 , 70 , 39 , 187 , 132 , 190 , 110 , 245 , 214 , 29 , 179 , 198 , 182 , 24 , 133 , 137 , 177 , 187 , 142 ]}}}]}}}, \"id\" : \"1\" }","title":"transaction"},{"location":"node-operators/cli/#utxos","text":"Get the unspent transaction outputs of the node. This shows how many UTXOs are available for your node to spend or collateralize. Docker docker exec witnet_node witnet node utxos Binary witnet node utxos Cargo cargo run -- node utxos The output includes information about: Total number of utxos Total number of utxos bigger than collateral minimum Total number of utxos older than collateral coinage The flag --long can be added to the command to get a detailed list of the UTXOs and whether each of them is spendable or collateralizable at this time.","title":"utxos"},{"location":"node-operators/docker-compose-service/","text":"Run as docker-compose services \u00b6 Prerequisites \u00b6 Install the current stable release of Docker Compose: sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.4/docker-compose- $( uname -s ) - $( uname -m ) \" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose Install the current stable release of parallel: sudo apt install parallel parallel --citation Test the installation of Docker Compose: docker-compose --version Clone the project's GitHub repository into your home directory: cd git clone https://github.com/witnet/witnet-operator-tools.git Go in the directory you are interested in \u00b6 for only one node \u00b6 cd witnet-operator-tools/docker/compose/bertux-operator-stable/ for several nodes (example: 5) \u00b6 cd witnet-operator-tools/docker/compose/bertux-operator-5/ Usage of docker-compose \u00b6 Start up the service: docker-compose up -d Follow the logs of the service: docker-compose logs -f When you want to stop the service: docker-compose stop When you want to remove the service: docker-compose down Every time you change the docker-compose.yaml file, you need to recreate the services by docker-compose : docker-compose down docker-compose up -d","title":"Run as docker-compose service"},{"location":"node-operators/docker-compose-service/#run-as-docker-compose-services","text":"","title":"Run as docker-compose services"},{"location":"node-operators/docker-compose-service/#prerequisites","text":"Install the current stable release of Docker Compose: sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.4/docker-compose- $( uname -s ) - $( uname -m ) \" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose Install the current stable release of parallel: sudo apt install parallel parallel --citation Test the installation of Docker Compose: docker-compose --version Clone the project's GitHub repository into your home directory: cd git clone https://github.com/witnet/witnet-operator-tools.git","title":"Prerequisites"},{"location":"node-operators/docker-compose-service/#go-in-the-directory-you-are-interested-in","text":"","title":"Go in the directory you are interested in"},{"location":"node-operators/docker-compose-service/#for-only-one-node","text":"cd witnet-operator-tools/docker/compose/bertux-operator-stable/","title":"for only one node"},{"location":"node-operators/docker-compose-service/#for-several-nodes-example-5","text":"cd witnet-operator-tools/docker/compose/bertux-operator-5/","title":"for several nodes (example: 5)"},{"location":"node-operators/docker-compose-service/#usage-of-docker-compose","text":"Start up the service: docker-compose up -d Follow the logs of the service: docker-compose logs -f When you want to stop the service: docker-compose stop When you want to remove the service: docker-compose down Every time you change the docker-compose.yaml file, you need to recreate the services by docker-compose : docker-compose down docker-compose up -d","title":"Usage of docker-compose"},{"location":"node-operators/hardware-requirements/","text":"Hardware requirements of running a Witnet node \u00b6 Witnet mining uses a probabilistic BFT-alike consensus algorithm , so no Proof-of-Work is necessary . In addition, witnet-rust is written in Rust , one of the most performance-focussed and secure programming languages available. When compiled, the resulting binary is tailored to each specific platform, which guarantees near-zero overhead . The hardware requirements for running a full node are therefore incredibly low . Obviously, the more resources you spare when provisioning your machine, the better it will perform and the less likely you are to face problems. This is a quick checklist on what to look for: A good amount of disk space (somewhere in the 100s of GBs) is better for long term storage of the blockchain. Any modern laptop or desktop will run it flawlessly. Virtual private servers (VPS) should work too. Take into account however that some cloud providers may restrict the use of blockchain protocols . Also, your node may get poor connectivity with the rest of the network because of bucketing . Raspberry Pis , especially the Pi 3 Model B and Pi 4 Model B , are also supported and, in our experience, are a great, inexpensive way of running a Witnet node. For example, here's a $15 Raspberry Pi Zero mining blocks on the Witnet Testnet in 2019 .","title":"Hardware requirements"},{"location":"node-operators/hardware-requirements/#hardware-requirements-of-running-a-witnet-node","text":"Witnet mining uses a probabilistic BFT-alike consensus algorithm , so no Proof-of-Work is necessary . In addition, witnet-rust is written in Rust , one of the most performance-focussed and secure programming languages available. When compiled, the resulting binary is tailored to each specific platform, which guarantees near-zero overhead . The hardware requirements for running a full node are therefore incredibly low . Obviously, the more resources you spare when provisioning your machine, the better it will perform and the less likely you are to face problems. This is a quick checklist on what to look for: A good amount of disk space (somewhere in the 100s of GBs) is better for long term storage of the blockchain. Any modern laptop or desktop will run it flawlessly. Virtual private servers (VPS) should work too. Take into account however that some cloud providers may restrict the use of blockchain protocols . Also, your node may get poor connectivity with the rest of the network because of bucketing . Raspberry Pis , especially the Pi 3 Model B and Pi 4 Model B , are also supported and, in our experience, are a great, inexpensive way of running a Witnet node. For example, here's a $15 Raspberry Pi Zero mining blocks on the Witnet Testnet in 2019 .","title":"Hardware requirements of running a Witnet node"},{"location":"node-operators/json-rpc/","text":"","title":"Json rpc"},{"location":"node-operators/systemd-service/","text":"Run as systemd service \u00b6 The runner.sh script automatically downloads and installs the latest version of the Witnet node software ( witnet-rust ). It can also be used to update to the latest version, since it will keep all the block chain data and the configuration file in the hidden .witnet directory. For Testnet 7.3 and greater, the configuration file needs to be customized with the public IP and port of the node, which must be set at the public_addr field in witnet.toml . Create the witnet user dedicated to running the node: sudo adduser witnet Clone the project's GitHub repository into your home directory and enter it: cd git clone https://github.com/witnet/witnet-operator-tools.git cd witnet-operator-tools Install latest version with the witnet user dedicated to running the node: sudo -u witnet ./systemd/runner.sh Copy the witnet.service file into /lib/systemd/system/ : sudo cp systemd/witnet.service /lib/systemd/system/witnet.service Every time you change the witnet.service file, you need to reload the systemd daemon: sudo systemctl daemon-reload Enable the service: sudo systemctl enable witnet.service Start the service: sudo systemctl start witnet.service See the logs of the service: journalctl -f -u witnet.service When you want to restart the service: sudo systemctl restart witnet.service","title":"Run as systemd service"},{"location":"node-operators/systemd-service/#run-as-systemd-service","text":"The runner.sh script automatically downloads and installs the latest version of the Witnet node software ( witnet-rust ). It can also be used to update to the latest version, since it will keep all the block chain data and the configuration file in the hidden .witnet directory. For Testnet 7.3 and greater, the configuration file needs to be customized with the public IP and port of the node, which must be set at the public_addr field in witnet.toml . Create the witnet user dedicated to running the node: sudo adduser witnet Clone the project's GitHub repository into your home directory and enter it: cd git clone https://github.com/witnet/witnet-operator-tools.git cd witnet-operator-tools Install latest version with the witnet user dedicated to running the node: sudo -u witnet ./systemd/runner.sh Copy the witnet.service file into /lib/systemd/system/ : sudo cp systemd/witnet.service /lib/systemd/system/witnet.service Every time you change the witnet.service file, you need to reload the systemd daemon: sudo systemctl daemon-reload Enable the service: sudo systemctl enable witnet.service Start the service: sudo systemctl start witnet.service See the logs of the service: journalctl -f -u witnet.service When you want to restart the service: sudo systemctl restart witnet.service","title":"Run as systemd service"},{"location":"node-operators/wallet-api/","text":"","title":"Wallet api"},{"location":"overview/concepts/","text":"What is Witnet? \u00b6 The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Smart Contracts Are Not What You Were Told \u00b6 Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. In reality, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is, once they are created, no one can stop them from doing exactly what they were created for. They obey their own source code, and censorship is impossible. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom . Blockchain Oracles, And Their Problem \u00b6 Given that smart contracts must be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, then you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" . The Solution: A Decentralized Oracle Network \u00b6 The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014 colloquially named witnesses - who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved, if a majority of them are incentivized to report the retrieved data honestly, and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger both for the operation of the protocol, and for the wit token (which incentives the network players to abide by the protocol and ensures they are liable for any misbehavior). Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data on behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not computationally expensive. The protocol has been designed to ensure utmost decentralization and fairness, so each witness' weight within the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the \"miners\" are not actual human beings sitting in front of a computer, manually fulfilling assignments. Instead, the \"miners\" are just computers running a software (witnet-rust) that automatically receive and execute a series of tasks. 100% Truth, 0% Trust \u00b6 Data retrieved, attested and delivered using the Witnet protocol is reliable not because of a central authority, but because it comes from anonymous nodes, incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not to spot fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"What is Witnet?"},{"location":"overview/concepts/#what-is-witnet","text":"The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity.","title":"What is Witnet?"},{"location":"overview/concepts/#smart-contracts-are-not-what-you-were-told","text":"Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. In reality, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is, once they are created, no one can stop them from doing exactly what they were created for. They obey their own source code, and censorship is impossible. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom .","title":"Smart Contracts Are Not What You Were Told"},{"location":"overview/concepts/#blockchain-oracles-and-their-problem","text":"Given that smart contracts must be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, then you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" .","title":"Blockchain Oracles, And Their Problem"},{"location":"overview/concepts/#the-solution-a-decentralized-oracle-network","text":"The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014 colloquially named witnesses - who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved, if a majority of them are incentivized to report the retrieved data honestly, and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger both for the operation of the protocol, and for the wit token (which incentives the network players to abide by the protocol and ensures they are liable for any misbehavior). Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data on behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not computationally expensive. The protocol has been designed to ensure utmost decentralization and fairness, so each witness' weight within the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the \"miners\" are not actual human beings sitting in front of a computer, manually fulfilling assignments. Instead, the \"miners\" are just computers running a software (witnet-rust) that automatically receive and execute a series of tasks.","title":"The Solution: A Decentralized Oracle Network"},{"location":"overview/concepts/#100-truth-0-trust","text":"Data retrieved, attested and delivered using the Witnet protocol is reliable not because of a central authority, but because it comes from anonymous nodes, incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not to spot fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"100% Truth, 0% Trust"},{"location":"overview/glossary/","text":"Glossary \u00b6 Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Nanowit : also nWit , the billionth fraction of a wit token. That is, 1 x 10\u22129 wit in scientific notation or standard form. One nanowit is the minimum amount of value that can exist on its own in the Witnet protocol, i.e. you cannot divide wits any further, just like you cannot divide dollars or euros further than cents. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/glossary/#glossary","text":"Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Nanowit : also nWit , the billionth fraction of a wit token. That is, 1 x 10\u22129 wit in scientific notation or standard form. One nanowit is the minimum amount of value that can exist on its own in the Witnet protocol, i.e. you cannot divide wits any further, just like you cannot divide dollars or euros further than cents. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/software/","text":"Witnet Software ecosystem \u00b6 Witnet-Rust \u00b6 Witnet-Rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust is experimental software running on experimental network protocols: All the main components are in place\u2014but they need yet to be battle tested before Mainnet. Testnet-8 is live. Here's the roadmap and this is how to run a node . The Witnet community is doing its best to make witnet-rust rock solid as soon as possible. Contributions are more than welcome. Sheikah \u00b6 Sheikah is a Witnet-compatible desktop wallet, data requests and smart contracts development environment. Ethereum Bridge \u00b6 The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is composed of three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust , which monitors the WBI for new requests and also scans","title":"Software"},{"location":"overview/software/#witnet-software-ecosystem","text":"","title":"Witnet Software ecosystem"},{"location":"overview/software/#witnet-rust","text":"Witnet-Rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust is experimental software running on experimental network protocols: All the main components are in place\u2014but they need yet to be battle tested before Mainnet. Testnet-8 is live. Here's the roadmap and this is how to run a node . The Witnet community is doing its best to make witnet-rust rock solid as soon as possible. Contributions are more than welcome.","title":"Witnet-Rust"},{"location":"overview/software/#sheikah","text":"Sheikah is a Witnet-compatible desktop wallet, data requests and smart contracts development environment.","title":"Sheikah"},{"location":"overview/software/#ethereum-bridge","text":"The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is composed of three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust , which monitors the WBI for new requests and also scans","title":"Ethereum Bridge"},{"location":"protocol/blocks/","text":"","title":"Blocks"},{"location":"protocol/reputation/","text":"Reputation System \u00b6","title":"Reputation System"},{"location":"protocol/reputation/#reputation-system","text":"","title":"Reputation System"},{"location":"protocol/serialization/","text":"","title":"Serialization"},{"location":"protocol/sortition/","text":"In Witnet, the entire network of nodes does not execute every task assigned to the network. Instead, per-task random committees composed of a subset of all available nodes are selected to perform each task. In order to be selected for one of these committees, each peer must first \"discover\" whether it is eligible. This eligibility method - somewhat comparable to someone finding out whether they hold a winning lottery ticket - is usually referred to as a \"cryptographic sortition scheme\". Typically, cryptographic sortition schemes base eligibility on whether the randomly drawn number falls below a given target value. In this case, probability of eligibility depends on the target value; the higher the value, the higher the odds that peers will be eligible. In Witnet, the probability of being eligible is biased by a node's reputation - by how \"honestly\" it has behaved in previous tasks. The cryptographic sortition in Witnet is defined as follows: VRF refers to the deterministic output of a Verifiable Random Function algorithm performed with key M i , and I i t refers to the influence (in terms of reputation) of peer i at time t. The task id represents the task which the node is trying to be eligible for. As specified, if the VRF output falls below the target value, then the node is eligible to perform the task. Each peer can individually determine its sortition without interacting with any other peer in the network. The random value is common to all peers (using the VRF random output of the last block). There are several properties that a cryptographic sortition needs to fullfil. The utilization of Verifiable Random Functions to select committees offers us the following properties: Collision resistance - it is difficult to discover two inputs that map to the same output. Pseudorandomness - the output is indistinguishable from random by anyone without the secret key. Trusted uniqueness - with a public key, a VRF input m corresponds to a unique output \u03b2. Verifiability - with a public key and a VRF output, nodes can verify whether the VRF was computed correctly. For more information on VRFs please check our medium post . Tip VRFs offer all the properties we needed for our cryptographic sortition mechanisms. If instead an ECDSA signature plus hash scheme was utilized, nodes could run their lottery as many times as they wanted (since ECDSA does not offer verifiable determinism properties).","title":"Sortition"},{"location":"protocol/transactions/","text":"","title":"Transactions"},{"location":"protocol/data-requests/examples/","text":"Examples \u00b6 What's the weather in Berlin? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the OpenWeatherMap API and returns the current weather conditions in Berlin. Retrieval stage \u00b6 Javascript new Witnet . Script () . parseJSON () // Parse the string, which we now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"weather\" ) // Get the value associated to the `weather` key . asMap () // Treat that as a Javascript object too . get ( \"temp\" ) // Now get the value associated to the `weather` key . asFloat (); // Finally treat that as a floating point number RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"weather\" ], BYTES_ASMAP , [ MAP_GET , \"temp\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"weather\" ], 116 , [ 97 , \"temp\" ], 114 ] CBOR (Base16) 8618451874821861477765617468657218748218614474656 D701872 Aggregation stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . greaterThan , - 30 ) . filter ( Witnet . Types . FILTERS . lessThan , 50 ) . filter ( Witnet . Types . FILTERS . deviationStandard ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATERTHAN , - 30 ], [ ARRAY_FILTER , FILTER_LESSTHAN , 50 ], [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 0 , - 30 ], [ 83 , 1 , 50 ], [ 83 , 5 ], [ 87 , 3 ] ] CBOR (Base16) 8483185300381 D8318530118328218530582185703 Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and return the arithmetic mean of the remaining values in the Array . Tally stage \u00b6 The following tally script is quite generic but should work for most cases where we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array What's the USD price of a bitcoin? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the Coinbase price API that returns the current price of a bitcoin in US dollars. Retrieval stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"bpi\" ) . asMap () . get ( \"usd\" ) . asMap () . get ( \"rate_float\" ) . asFloat () RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"bpi\" ], BYTES_ASMAP , [ MAP_GET , \"USD\" ], BYTES_ASMAP , [ MAP_GET , \"rate_float\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"bpi\" ], 116 , [ 97 , \"usd\" ], 116 , [ 97 , \"rate_float\" ], 114 ] CBOR (Base16) 88184518748218616362706918748218616375736418748218616 A726174655F666C6F61741872 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map , Take the value of the \"bpi\" key, Treat the structure as Map . Take the value of the \"USD\" key, Treat the structure as Map . Take the value of the \"rate_float\" , Return the value as Float . Aggregation stage \u00b6 The following tally script is quite generic but should work for most cases where we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array Tally stage \u00b6 For the tally stage we can safely use the same generic script as for the aggregation stage. Heads or tails? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the Australian National University Quantum Random Numbers Server that returns true random numbers in the [0, 255] range generated in real-time by measuring the quantum fluctuations of the vacuum in a laboratory. The tally stage computes the average of the values reported by multiple witness nodes, which will produce a point in the [0, 255] range that is normally distributed around the half-range, i.e. it will fall in any of the [0, 127] or [128, 255] sub-ranges with a 50% probability. Finally, it checks which side of the half-range the point actually fell, and maps that onto a String with value heads or tails . Retrieval stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"data\" ) . asArray () . get ( 0 ) . asInteger () RADON-AST [ STRING_PARSEJSON , BYTES_TOMAP , [ MAP_GET , \"data\" ], BYTES_TOARRAY , [ ARRAY_GET , 0 ], BYTES_ASARRAY ] RADON-JSON [ 69 , 116 , [ 97 , \"data\" ], 112 , [ 85 , 0 ], 115 ] CBOR (Base16) 861845187482186144646174611870821855001873 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map<String, Mixed> , Take the value of the \"data\" key as Mixed , Treat the structure as Array<Mixed> . Take the value at index 0 as Mixed , Emit the value as Float . Tally stage \u00b6 Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . INTEGER ]) . filter ( Witnet . Types . FILTERS . greaterOrEqualThan , 0 ) . filter ( Witnet . Types . FILTERS . lessOrEqualThan , 255 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) . round () . greaterThan ( 127 ) . match ({ true : \"tails\" }, \"heads\" ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATEROREQUALTHAN , 0 ], [ ARRAY_FILTER , FILTER_LESSOREQUALTHAN , 255 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ], FLOAT_ROUND , [ INTEGER_GREATERTHAN , 127 ], [ INTEGER_MATCH , { true : \"tails\" }, \"heads\" ] ] RADON-JSON [ [ 83 , 129 , 0 ], [ 83 , 128 , 255 ], [ 87 , 3 ], 60 , [ 36 , 127 ], [ 16 , { true : 'tails' }, 'heads' ] ] CBOR (Base16) 86831853188100831853188018 FF82185703183C821824187F8310A1F5457461696C73456865616473 Remove any items with value under 0 from Array , Remove any items with value over 255 from the remaining Array , Calculate the arithmetic mean of the remaining Array , Round the resulting Float to its closest Integer value, Check if the resulting Integer is greater than 127 , and continue with a Boolean of value true or false accordingly, Map the Boolean to String by converting false into \"heads\" and true into \"tails\" .","title":"Examples"},{"location":"protocol/data-requests/examples/#examples","text":"","title":"Examples"},{"location":"protocol/data-requests/examples/#whats-the-weather-in-berlin","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the OpenWeatherMap API and returns the current weather conditions in Berlin.","title":"What's the weather in Berlin?"},{"location":"protocol/data-requests/examples/#retrieval-stage","text":"Javascript new Witnet . Script () . parseJSON () // Parse the string, which we now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"weather\" ) // Get the value associated to the `weather` key . asMap () // Treat that as a Javascript object too . get ( \"temp\" ) // Now get the value associated to the `weather` key . asFloat (); // Finally treat that as a floating point number RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"weather\" ], BYTES_ASMAP , [ MAP_GET , \"temp\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"weather\" ], 116 , [ 97 , \"temp\" ], 114 ] CBOR (Base16) 8618451874821861477765617468657218748218614474656 D701872","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#aggregation-stage","text":"Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . greaterThan , - 30 ) . filter ( Witnet . Types . FILTERS . lessThan , 50 ) . filter ( Witnet . Types . FILTERS . deviationStandard ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATERTHAN , - 30 ], [ ARRAY_FILTER , FILTER_LESSTHAN , 50 ], [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 0 , - 30 ], [ 83 , 1 , 50 ], [ 83 , 5 ], [ 87 , 3 ] ] CBOR (Base16) 8483185300381 D8318530118328218530582185703 Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and return the arithmetic mean of the remaining values in the Array .","title":"Aggregation stage"},{"location":"protocol/data-requests/examples/#tally-stage","text":"The following tally script is quite generic but should work for most cases where we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array","title":"Tally stage"},{"location":"protocol/data-requests/examples/#whats-the-usd-price-of-a-bitcoin","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the Coinbase price API that returns the current price of a bitcoin in US dollars.","title":"What's the USD price of a bitcoin?"},{"location":"protocol/data-requests/examples/#retrieval-stage_1","text":"Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"bpi\" ) . asMap () . get ( \"usd\" ) . asMap () . get ( \"rate_float\" ) . asFloat () RADON-AST [ STRING_PARSEJSON , BYTES_ASMAP , [ MAP_GET , \"bpi\" ], BYTES_ASMAP , [ MAP_GET , \"USD\" ], BYTES_ASMAP , [ MAP_GET , \"rate_float\" ], BYTES_ASFLOAT ] RADON-JSON [ 69 , 116 , [ 97 , \"bpi\" ], 116 , [ 97 , \"usd\" ], 116 , [ 97 , \"rate_float\" ], 114 ] CBOR (Base16) 88184518748218616362706918748218616375736418748218616 A726174655F666C6F61741872 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map , Take the value of the \"bpi\" key, Treat the structure as Map . Take the value of the \"USD\" key, Treat the structure as Map . Take the value of the \"rate_float\" , Return the value as Float .","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#aggregation-stage_1","text":"The following tally script is quite generic but should work for most cases where we are trying to build consensus on Integer or Float data points. Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . FLOAT ]) . filter ( Witnet . Types . FILTERS . deviationStandard , 2 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) RADON-AST [ [ ARRAY_FILTER , FILTER_DEVIATIONSTANDARD , 2 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ] ] RADON-JSON [ [ 83 , 5 , 2 ], [ 87 , 3 ] ] CBOR (Base16) 82831853050282185703 Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array","title":"Aggregation stage"},{"location":"protocol/data-requests/examples/#tally-stage_1","text":"For the tally stage we can safely use the same generic script as for the aggregation stage.","title":"Tally stage"},{"location":"protocol/data-requests/examples/#heads-or-tails","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the Australian National University Quantum Random Numbers Server that returns true random numbers in the [0, 255] range generated in real-time by measuring the quantum fluctuations of the vacuum in a laboratory. The tally stage computes the average of the values reported by multiple witness nodes, which will produce a point in the [0, 255] range that is normally distributed around the half-range, i.e. it will fall in any of the [0, 127] or [128, 255] sub-ranges with a 50% probability. Finally, it checks which side of the half-range the point actually fell, and maps that onto a String with value heads or tails .","title":"Heads or tails?"},{"location":"protocol/data-requests/examples/#retrieval-stage_2","text":"Javascript new Witnet . Script ([ Witnet . TYPES . STRING ]) . parseJSON () . asMap () . get ( \"data\" ) . asArray () . get ( 0 ) . asInteger () RADON-AST [ STRING_PARSEJSON , BYTES_TOMAP , [ MAP_GET , \"data\" ], BYTES_TOARRAY , [ ARRAY_GET , 0 ], BYTES_ASARRAY ] RADON-JSON [ 69 , 116 , [ 97 , \"data\" ], 112 , [ 85 , 0 ], 115 ] CBOR (Base16) 861845187482186144646174611870821855001873 Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map<String, Mixed> , Take the value of the \"data\" key as Mixed , Treat the structure as Array<Mixed> . Take the value at index 0 as Mixed , Emit the value as Float .","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#tally-stage_2","text":"Javascript new Witnet . Script ([ Witnet . TYPES . ARRAY , Witnet . TYPES . INTEGER ]) . filter ( Witnet . Types . FILTERS . greaterOrEqualThan , 0 ) . filter ( Witnet . Types . FILTERS . lessOrEqualThan , 255 ) . reduce ( Witnet . Types . REDUCERS . averageMean ) . round () . greaterThan ( 127 ) . match ({ true : \"tails\" }, \"heads\" ) RADON-AST [ [ ARRAY_FILTER , FILTER_GREATEROREQUALTHAN , 0 ], [ ARRAY_FILTER , FILTER_LESSOREQUALTHAN , 255 ], [ ARRAY_REDUCE , REDUCER_AVERAGEMEAN ], FLOAT_ROUND , [ INTEGER_GREATERTHAN , 127 ], [ INTEGER_MATCH , { true : \"tails\" }, \"heads\" ] ] RADON-JSON [ [ 83 , 129 , 0 ], [ 83 , 128 , 255 ], [ 87 , 3 ], 60 , [ 36 , 127 ], [ 16 , { true : 'tails' }, 'heads' ] ] CBOR (Base16) 86831853188100831853188018 FF82185703183C821824187F8310A1F5457461696C73456865616473 Remove any items with value under 0 from Array , Remove any items with value over 255 from the remaining Array , Calculate the arithmetic mean of the remaining Array , Round the resulting Float to its closest Integer value, Check if the resulting Integer is greater than 127 , and continue with a Boolean of value true or false accordingly, Map the Boolean to String by converting false into \"heads\" and true into \"tails\" .","title":"Tally stage"},{"location":"protocol/data-requests/overview/","text":"Witnet requests \u00b6 Witnet requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand. Request life cycle \u00b6 Once a Witnet request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s. For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide. The RAD Engine \u00b6 The RAD Engine is the component in charge of processing Witnet requests. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All Witnet requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Attest and Deliver . RAD Object Notation (RADON) \u00b6 The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted. Creating Witnet requests \u00b6 The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can write RADON, it's not the best method. The standard way to compose Witnet requests is using the Witnet Truffle box , which you can learn about by following the price feed tutorial . The Sheikah desktop app (currently under heavy development) is also intended to be used as an IDE for visually and safely composing and testing Witnet requests.","title":"Overview"},{"location":"protocol/data-requests/overview/#witnet-requests","text":"Witnet requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand.","title":"Witnet requests"},{"location":"protocol/data-requests/overview/#request-life-cycle","text":"Once a Witnet request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s. For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide.","title":"Request life cycle"},{"location":"protocol/data-requests/overview/#the-rad-engine","text":"The RAD Engine is the component in charge of processing Witnet requests. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All Witnet requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Attest and Deliver .","title":"The RAD Engine"},{"location":"protocol/data-requests/overview/#rad-object-notation-radon","text":"The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted.","title":"RAD Object Notation (RADON)"},{"location":"protocol/data-requests/overview/#creating-witnet-requests","text":"The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can write RADON, it's not the best method. The standard way to compose Witnet requests is using the Witnet Truffle box , which you can learn about by following the price feed tutorial . The Sheikah desktop app (currently under heavy development) is also intended to be used as an IDE for visually and safely composing and testing Witnet requests.","title":"Creating Witnet requests"},{"location":"protocol/data-requests/radon-encoding/","text":"RADON encoding \u00b6 RADON scripts are encoded using CBOR , a very efficient, compact and widely supported data structure encoding. Look for example at this succinct (28 bytes) serialized RADON script: // As Hex string 8618431874821861677765617468657218748218616474656 D701872 // As Base64 string \"hhhDGHSCGGFnd2VhdGhlchh0ghhhZHRlbXAYcg==\" Once decoded, the resulting structure will represent this RADON script: [ STRING_PARSEJSON , // 0x45 MIXED_ASMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_ASMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_ASFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences, and at the same time represent high-level abstractions. In the Javascript-like representation of RADON that the Witnet Truffle box uses, the script above may resemble: new Witnet . Script () . parseJSON () . asMap () . get ( \"weather\" ) . asMap () . get ( \"temp\" ) . asFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"Encoding"},{"location":"protocol/data-requests/radon-encoding/#radon-encoding","text":"RADON scripts are encoded using CBOR , a very efficient, compact and widely supported data structure encoding. Look for example at this succinct (28 bytes) serialized RADON script: // As Hex string 8618431874821861677765617468657218748218616474656 D701872 // As Base64 string \"hhhDGHSCGGFnd2VhdGhlchh0ghhhZHRlbXAYcg==\" Once decoded, the resulting structure will represent this RADON script: [ STRING_PARSEJSON , // 0x45 MIXED_ASMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_ASMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_ASFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences, and at the same time represent high-level abstractions. In the Javascript-like representation of RADON that the Witnet Truffle box uses, the script above may resemble: new Witnet . Script () . parseJSON () . asMap () . get ( \"weather\" ) . asMap () . get ( \"temp\" ) . asFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"RADON encoding"},{"location":"try/next-steps/","text":"I got my Witnet node running. What's next? \u00b6 The first minutes and hours in your node's life \u00b6 As soon as the witnet_node container is up, it will do the following things in order: Try to open connections to other nodes in the network. It needs 8 \"outbound\" connections. This should take from several seconds to a few minutes. Discover what is the tip of the block chain , and download all the blocks from that chain. This can take from several minutes to several hours. The synchronization time depends heavily on how long the block chain is, but also on your Internet bandwidth, CPU speed, memory size and speed, and storage drive write throughput. Go into Synced status . In Synced status, your node will validate transactions and blocks in real time, and it will try itself to propose block candidates and participate in resolving data requests . What to expect from your node's balance and reputation \u00b6 Getting your first block proposal accepted by the network and minting your first wit tokens is not easy, and can take from a few minutes up to 48 hours (or more!) due to the probabilistic nature of the cryptographic sortition algorithm that rules the system. As with minting blocks, being assigned a request for the first time can take some time: from several minutes up to 48 hours (or more!). Once you have resolved at least one request, your node will earn reputation and it will start getting assignments more often. Don't panic Note that it is perfectly normal for a node to show 0 \"balance\", \"reputation\", \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. Monitoring your node's progress \u00b6 Here are some useful commands that you can use to keep track of how your node is performing in the network. A complete documentation of all the CLI methods is available in the node operator docs . nodeStats \u00b6 Docker docker exec witnet_node witnet node nodeStats Cargo cargo run --release -- node nodeStats Binary witnet node nodeStats Among other information, this shows counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"): balance \u00b6 Docker docker exec witnet_node witnet node balance Cargo cargo run --release -- node balance Binary witnet node balance The balance command will print your node's current balance. reputation \u00b6 Docker docker exec witnet_node witnet node reputation Cargo cargo run --release -- node reputation Binary witnet node reputation The reputation command will print your node's current reputation score. Reputation is tricky Despite its name, the reputation metric that exists in the Witnet protocol is not as vital as reputation is in real life. The reputation score of a node gives a rough idea about its performance, but it is heavily influenced by randomness and luck. It is perfectly normal that the reputation score goes up and down over time, sometimes smoothly, sometimes more abruptly. Do not get too obsessed about it! Check ports and incoming connections \u00b6 To check if the listening port is correctly opened to the Internet, you can use a port forwarding testing tool or try to open a connection to your public IP from a device that is not in the same network as your node: Telnet # If you get stuck when running this command, it is indeed a good sign that # the connection was stablished. To exist a Telnet session, press \"Ctrl + ]\", # then write \"quit\" and press Enter. telnet your_public_ip 21337 GNU Netcat nc -vz your_public_ip:21337 The final check to verify that your port is correctly forwarded is using the peers method to look if any of the peer connections is tagged as \"inbound\": Docker docker exec witnet_node witnet node peers Cargo cargo run --release -- node peers Binary witnet node peers Multiple nodes in the same device or network Multiple Witnet nodes can run in the same device or network and still get incoming connections. This is possible by forwarding a different external port (e.g. 22337 ) to the port of your second node. However, your second node may require setting an additional parameter in its configuration file so that it is aware of the new port. Please read below how to customize the configuration file. The parameter you need to adjust is public_addr . Customize configuration \u00b6 A custom witnet.toml configuration file can be used to adjust some parameters of the node. The configuration file itself contains detailed explanations for each parameter. If you created your node following this guide, your witnet.toml file will be found in the ~/.witnet/config folder, right in your user's directory. You can easily edit the configuration file like this: Vim (Mac OS) vim /users/$USER/.witnet/config/witnet.toml Vim (GNU/Linux) vim /home/$USER/.witnet/config/witnet.toml Nano (GNU/Linux) nano /home/$USER/.witnet/config/witnet.toml Long term maintenance of your node \u00b6 There are some operations that are recommended from time to time to make sure your node is in perfect order: Give a look to the result of the nodeStats , balance and reputation commands. Check that you are getting incoming connections as explained above. Keep an eye on announcements for software and networks upgrades through the Witnet Community Discord and Telegram to make sure that you are running the latest release, which should give your node the best performance, liveness and security. Restart your node once in a while (e.g. docker restart witnet_node ) so that the node can perform some housekeeping operations. This helps reducing memory footprint and optimize disk space.","title":"Next Steps"},{"location":"try/next-steps/#i-got-my-witnet-node-running-whats-next","text":"","title":"I got my Witnet node running. What's next?"},{"location":"try/next-steps/#the-first-minutes-and-hours-in-your-nodes-life","text":"As soon as the witnet_node container is up, it will do the following things in order: Try to open connections to other nodes in the network. It needs 8 \"outbound\" connections. This should take from several seconds to a few minutes. Discover what is the tip of the block chain , and download all the blocks from that chain. This can take from several minutes to several hours. The synchronization time depends heavily on how long the block chain is, but also on your Internet bandwidth, CPU speed, memory size and speed, and storage drive write throughput. Go into Synced status . In Synced status, your node will validate transactions and blocks in real time, and it will try itself to propose block candidates and participate in resolving data requests .","title":"The first minutes and hours in your node's life"},{"location":"try/next-steps/#what-to-expect-from-your-nodes-balance-and-reputation","text":"Getting your first block proposal accepted by the network and minting your first wit tokens is not easy, and can take from a few minutes up to 48 hours (or more!) due to the probabilistic nature of the cryptographic sortition algorithm that rules the system. As with minting blocks, being assigned a request for the first time can take some time: from several minutes up to 48 hours (or more!). Once you have resolved at least one request, your node will earn reputation and it will start getting assignments more often. Don't panic Note that it is perfectly normal for a node to show 0 \"balance\", \"reputation\", \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons.","title":"What to expect from your node's balance and reputation"},{"location":"try/next-steps/#monitoring-your-nodes-progress","text":"Here are some useful commands that you can use to keep track of how your node is performing in the network. A complete documentation of all the CLI methods is available in the node operator docs .","title":"Monitoring your node's progress"},{"location":"try/next-steps/#nodestats","text":"Docker docker exec witnet_node witnet node nodeStats Cargo cargo run --release -- node nodeStats Binary witnet node nodeStats Among other information, this shows counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"):","title":"nodeStats"},{"location":"try/next-steps/#balance","text":"Docker docker exec witnet_node witnet node balance Cargo cargo run --release -- node balance Binary witnet node balance The balance command will print your node's current balance.","title":"balance"},{"location":"try/next-steps/#reputation","text":"Docker docker exec witnet_node witnet node reputation Cargo cargo run --release -- node reputation Binary witnet node reputation The reputation command will print your node's current reputation score. Reputation is tricky Despite its name, the reputation metric that exists in the Witnet protocol is not as vital as reputation is in real life. The reputation score of a node gives a rough idea about its performance, but it is heavily influenced by randomness and luck. It is perfectly normal that the reputation score goes up and down over time, sometimes smoothly, sometimes more abruptly. Do not get too obsessed about it!","title":"reputation"},{"location":"try/next-steps/#check-ports-and-incoming-connections","text":"To check if the listening port is correctly opened to the Internet, you can use a port forwarding testing tool or try to open a connection to your public IP from a device that is not in the same network as your node: Telnet # If you get stuck when running this command, it is indeed a good sign that # the connection was stablished. To exist a Telnet session, press \"Ctrl + ]\", # then write \"quit\" and press Enter. telnet your_public_ip 21337 GNU Netcat nc -vz your_public_ip:21337 The final check to verify that your port is correctly forwarded is using the peers method to look if any of the peer connections is tagged as \"inbound\": Docker docker exec witnet_node witnet node peers Cargo cargo run --release -- node peers Binary witnet node peers Multiple nodes in the same device or network Multiple Witnet nodes can run in the same device or network and still get incoming connections. This is possible by forwarding a different external port (e.g. 22337 ) to the port of your second node. However, your second node may require setting an additional parameter in its configuration file so that it is aware of the new port. Please read below how to customize the configuration file. The parameter you need to adjust is public_addr .","title":"Check ports and incoming connections"},{"location":"try/next-steps/#customize-configuration","text":"A custom witnet.toml configuration file can be used to adjust some parameters of the node. The configuration file itself contains detailed explanations for each parameter. If you created your node following this guide, your witnet.toml file will be found in the ~/.witnet/config folder, right in your user's directory. You can easily edit the configuration file like this: Vim (Mac OS) vim /users/$USER/.witnet/config/witnet.toml Vim (GNU/Linux) vim /home/$USER/.witnet/config/witnet.toml Nano (GNU/Linux) nano /home/$USER/.witnet/config/witnet.toml","title":"Customize configuration"},{"location":"try/next-steps/#long-term-maintenance-of-your-node","text":"There are some operations that are recommended from time to time to make sure your node is in perfect order: Give a look to the result of the nodeStats , balance and reputation commands. Check that you are getting incoming connections as explained above. Keep an eye on announcements for software and networks upgrades through the Witnet Community Discord and Telegram to make sure that you are running the latest release, which should give your node the best performance, liveness and security. Restart your node once in a while (e.g. docker restart witnet_node ) so that the node can perform some housekeeping operations. This helps reducing memory footprint and optimize disk space.","title":"Long term maintenance of your node"},{"location":"try/run-a-node/","text":"Running a Node in the Witnet Testnet \u00b6 The Witnet Testnet is open for anyone to join and test it by running their own full node. Running a node on the Witnet Mainnet is not possible before Mainnet is launched. You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to connect your Ethereum contracts to external APIs using Witnet . Hardware requirements \u00b6 Hardware requirements are listed in the node operators docs . Up and running in 1 minute, using Docker \u00b6 The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. For alternate installation methods or more complex setups, take a look at the docker-compose and systemd integrations. Firstly, you need to install Docker on the device you will be running the node from. Note: some GNU/Linux distributions require some extra steps to get Docker up and running. The Witnet docker image downloads and runs a Witnet node in the latest Testnet in just a matter on seconds. To start a node, use: Multiline docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust One-liner docker run -d --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Raspberry Pi 4 users For some reason, Raspbian on Raspberry Pi 4 (not the case for older versions) requires your containers to operate in privileged mode. When running the command above, simply add the --privileged flag: docker run -d --privileged --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Now what? \u00b6 There are two important things you should do now to make the most of your Witnet node: Open ports as explained below. Follow the Next Steps guide to learn how to check the node status, progress and statistics. Open your ports! \u00b6 The best way to contribute to the growth and sustainability of the Witnet network is by opening up the listening port of your node , so that other nodes in the network can download block chain data from you and your transactions can be broadcasted more quickly . For this feature to be effective, you will also need your IP address to be public (and ideally, static). If you are operating a node in your home network, you can request your ISP to assign you a static IP address or at least disable CGN on it. Depending on your setup, this will normally imply changing the settings on your router or firewall so as to forward all incoming connections to port 21337 from your external IP into the IP of the device or interface where the node is running. You can find out how to verify that your ports are open in the Next Steps guide. What about Witnet data requests? \u00b6 As soon as your node is synced, it will be able to start resolving data requests from others. You can learn how to produce Witnet requests by following the tutorial on how to create a Bitcoin price feed using Ethereum and Witnet . In addition, we will be soon releasing a user-friendly editor in the Sheikah desktop app that will enable to compose data requests and RADON scripts visually. In the meantime, you can play around with this community-built request editor .","title":"Run a Node"},{"location":"try/run-a-node/#running-a-node-in-the-witnet-testnet","text":"The Witnet Testnet is open for anyone to join and test it by running their own full node. Running a node on the Witnet Mainnet is not possible before Mainnet is launched. You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to connect your Ethereum contracts to external APIs using Witnet .","title":"Running a Node in the Witnet Testnet"},{"location":"try/run-a-node/#hardware-requirements","text":"Hardware requirements are listed in the node operators docs .","title":"Hardware requirements"},{"location":"try/run-a-node/#up-and-running-in-1-minute-using-docker","text":"The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. For alternate installation methods or more complex setups, take a look at the docker-compose and systemd integrations. Firstly, you need to install Docker on the device you will be running the node from. Note: some GNU/Linux distributions require some extra steps to get Docker up and running. The Witnet docker image downloads and runs a Witnet node in the latest Testnet in just a matter on seconds. To start a node, use: Multiline docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust One-liner docker run -d --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Raspberry Pi 4 users For some reason, Raspbian on Raspberry Pi 4 (not the case for older versions) requires your containers to operate in privileged mode. When running the command above, simply add the --privileged flag: docker run -d --privileged --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust","title":"Up and running in 1 minute, using Docker"},{"location":"try/run-a-node/#now-what","text":"There are two important things you should do now to make the most of your Witnet node: Open ports as explained below. Follow the Next Steps guide to learn how to check the node status, progress and statistics.","title":"Now what?"},{"location":"try/run-a-node/#open-your-ports","text":"The best way to contribute to the growth and sustainability of the Witnet network is by opening up the listening port of your node , so that other nodes in the network can download block chain data from you and your transactions can be broadcasted more quickly . For this feature to be effective, you will also need your IP address to be public (and ideally, static). If you are operating a node in your home network, you can request your ISP to assign you a static IP address or at least disable CGN on it. Depending on your setup, this will normally imply changing the settings on your router or firewall so as to forward all incoming connections to port 21337 from your external IP into the IP of the device or interface where the node is running. You can find out how to verify that your ports are open in the Next Steps guide.","title":"Open your ports!"},{"location":"try/run-a-node/#what-about-witnet-data-requests","text":"As soon as your node is synced, it will be able to start resolving data requests from others. You can learn how to produce Witnet requests by following the tutorial on how to create a Bitcoin price feed using Ethereum and Witnet . In addition, we will be soon releasing a user-friendly editor in the Sheikah desktop app that will enable to compose data requests and RADON scripts visually. In the meantime, you can play around with this community-built request editor .","title":"What about Witnet data requests?"},{"location":"try/use-from-ethereum/","text":"Using Witnet from Ethereum / Solidity \u00b6 Using Witnet as an oracle for resolving your Ethereum smart contracts is very simple, thanks to the Witnet Truffle box and the UsingWitnet Solidity library. Write your first Witnet-powered Ethereum contract \u00b6 The Witnet community has put together this comprehensive tutorial with instructions on how to create a price feed Ethereum contract using Solidity, Truffle and Witnet so that anyone can get started in minutes. How can Ethereum contracts communicate with Witnet? \u00b6 Witnet is a separate blockchain. However, communication between Ethereum and Witnet is enabled via the Witnet Bridge Interface and the bridge nodes ; these nodes operate in both blockchains and get randomly selected to perform the job of relaying requests and responses back and forth between the chains. This system, which resembles the architecture of a sidechain, is better described in this Medium post . Do I need wit tokens in order to access Witnet from Ethereum? \u00b6 No :) Accessing Witnet from Ethereum requires you to neither own nor pay any wit tokens; instead, bridge nodes are paid in ETH, and spend their own wit tokens to post your requests into Witnet on your behalf.","title":"Connect your Ethereum contracts to external APIs"},{"location":"try/use-from-ethereum/#using-witnet-from-ethereum-solidity","text":"Using Witnet as an oracle for resolving your Ethereum smart contracts is very simple, thanks to the Witnet Truffle box and the UsingWitnet Solidity library.","title":"Using Witnet from Ethereum / Solidity"},{"location":"try/use-from-ethereum/#write-your-first-witnet-powered-ethereum-contract","text":"The Witnet community has put together this comprehensive tutorial with instructions on how to create a price feed Ethereum contract using Solidity, Truffle and Witnet so that anyone can get started in minutes.","title":"Write your first Witnet-powered Ethereum contract"},{"location":"try/use-from-ethereum/#how-can-ethereum-contracts-communicate-with-witnet","text":"Witnet is a separate blockchain. However, communication between Ethereum and Witnet is enabled via the Witnet Bridge Interface and the bridge nodes ; these nodes operate in both blockchains and get randomly selected to perform the job of relaying requests and responses back and forth between the chains. This system, which resembles the architecture of a sidechain, is better described in this Medium post .","title":"How can Ethereum contracts communicate with Witnet?"},{"location":"try/use-from-ethereum/#do-i-need-wit-tokens-in-order-to-access-witnet-from-ethereum","text":"No :) Accessing Witnet from Ethereum requires you to neither own nor pay any wit tokens; instead, bridge nodes are paid in ETH, and spend their own wit tokens to post your requests into Witnet on your behalf.","title":"Do I need wit tokens in order to access Witnet from Ethereum?"},{"location":"tutorials/bitcoin-price-feed/aggregations/","text":"3. Define the aggregator and tally functions \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. What is an aggregator? \u00b6 Aggregators define how to reduce or merge the result of multiple sources into a single data point. They are similar to JavaScript's .reduce () method or the fold higher-order function from many programming languages. In addition, aggregation functions give the chance to filter out any outliers by using one or more statistical primitives. Every Witnet request needs to have exactly one aggregator function . Aggregators contain zero, one or more filters . Aggregators contain exactly one reducer . When a Witnet node gets a request assigned for resolution, it retrieves every source, applies the source companion scripts on the retrieved data, collects the results into an Array , and then apply the aggregator on it, first running the filters and later the reducer. What is a tally function? \u00b6 Tallies are really similar to aggregators, but instead of merging multiple sources, they merge the results reported by multiple Witnet nodes. Let's average multiple sources \u00b6 In this case, you will be using an aggregator that filters out any outliers coming from the two sources that you defined before, and returns the average mean of the Float values that pass the filter: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) That will be enough to reduce the Array containing the Float responses of the two sources into a single Float that represents the average mean of non-outliers values. You can now continue with the tally function. Tally by average \u00b6 For this tutorial, we will be using a tally function that is quite similar to the aggregation function: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.0 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) Note, however, that in this case the deviation filter is using a narrower threshold ( 1.0 instead of 1.5 ). This is to ensure that malicious data points will not affect the final result, and that the witnesses that produced such outliers will be punished for their misbehavior. Quick recap \u00b6 At this point, requests/BitcoinPrice.js should look like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.0 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) Now it is time to put everything together and fine-tune the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"3. Define aggregator / tally"},{"location":"tutorials/bitcoin-price-feed/aggregations/#3-define-the-aggregator-and-tally-functions","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"3. Define the aggregator and tally functions"},{"location":"tutorials/bitcoin-price-feed/aggregations/#what-is-an-aggregator","text":"Aggregators define how to reduce or merge the result of multiple sources into a single data point. They are similar to JavaScript's .reduce () method or the fold higher-order function from many programming languages. In addition, aggregation functions give the chance to filter out any outliers by using one or more statistical primitives. Every Witnet request needs to have exactly one aggregator function . Aggregators contain zero, one or more filters . Aggregators contain exactly one reducer . When a Witnet node gets a request assigned for resolution, it retrieves every source, applies the source companion scripts on the retrieved data, collects the results into an Array , and then apply the aggregator on it, first running the filters and later the reducer.","title":"What is an aggregator?"},{"location":"tutorials/bitcoin-price-feed/aggregations/#what-is-a-tally-function","text":"Tallies are really similar to aggregators, but instead of merging multiple sources, they merge the results reported by multiple Witnet nodes.","title":"What is a tally function?"},{"location":"tutorials/bitcoin-price-feed/aggregations/#lets-average-multiple-sources","text":"In this case, you will be using an aggregator that filters out any outliers coming from the two sources that you defined before, and returns the average mean of the Float values that pass the filter: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) That will be enough to reduce the Array containing the Float responses of the two sources into a single Float that represents the average mean of non-outliers values. You can now continue with the tally function.","title":"Let's average multiple sources"},{"location":"tutorials/bitcoin-price-feed/aggregations/#tally-by-average","text":"For this tutorial, we will be using a tally function that is quite similar to the aggregation function: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.0 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) Note, however, that in this case the deviation filter is using a narrower threshold ( 1.0 instead of 1.5 ). This is to ensure that malicious data points will not affect the final result, and that the witnesses that produced such outliers will be punished for their misbehavior.","title":"Tally by average"},{"location":"tutorials/bitcoin-price-feed/aggregations/#quick-recap","text":"At this point, requests/BitcoinPrice.js should look like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.0 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) Now it is time to put everything together and fine-tune the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Quick recap"},{"location":"tutorials/bitcoin-price-feed/compiling/","text":"5. Compile the request \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Compiling the request could not be easier: npm npm run compile-requests yarn yarn compile-requests The compile-requests npm task will: Analyze your requests for syntactic and semantic errors. Warn you of any security issues and broken incentives. Try to compile the requests into Witnet bytecode. Put the bytecode into auxiliary Solidity contracts that you can import into your own contracts. Write migration files with default constructor arguments that you can later customize. If you now take a look in the contracts/requests folder, you will notice a new file called BitcoinPrice.sol . It will contain something like this: pragma solidity ^ 0.5.0 ; import \"witnet-ethereum-bridge/contracts/Request.sol\" ; // The bytecode of the BitcoinPrice request that will be sent to Witnet contract BitcoinPriceRequest is Request { constructor () Request ( hex \"0aaf0108b6cfb3ec051237122468747470733a2f2f7777772e6269747374616d702e6e65742f6170692f7469636b65722f1a0f8418451874821861646c6173741872125c123168747470733a2f2f6170692e636f696e6465736b2e636f6d2f76312f6270692f63757272656e7470726963652e6a736f6e1a2788184518748218616362706918748218616355534418748218616a726174655f666c6f617418721a070a05818218570322070a058182185703100a18042002280130013801\" ) public { } } As you can see, the contract contains the byte code for the request you just wrote, exported as a Solidity contract that you can then import and instantiate from your own contracts. The next step is to write your main consumer contract . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"5. Compile the request"},{"location":"tutorials/bitcoin-price-feed/compiling/#5-compile-the-request","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Compiling the request could not be easier: npm npm run compile-requests yarn yarn compile-requests The compile-requests npm task will: Analyze your requests for syntactic and semantic errors. Warn you of any security issues and broken incentives. Try to compile the requests into Witnet bytecode. Put the bytecode into auxiliary Solidity contracts that you can import into your own contracts. Write migration files with default constructor arguments that you can later customize. If you now take a look in the contracts/requests folder, you will notice a new file called BitcoinPrice.sol . It will contain something like this: pragma solidity ^ 0.5.0 ; import \"witnet-ethereum-bridge/contracts/Request.sol\" ; // The bytecode of the BitcoinPrice request that will be sent to Witnet contract BitcoinPriceRequest is Request { constructor () Request ( hex \"0aaf0108b6cfb3ec051237122468747470733a2f2f7777772e6269747374616d702e6e65742f6170692f7469636b65722f1a0f8418451874821861646c6173741872125c123168747470733a2f2f6170692e636f696e6465736b2e636f6d2f76312f6270692f63757272656e7470726963652e6a736f6e1a2788184518748218616362706918748218616355534418748218616a726174655f666c6f617418721a070a05818218570322070a058182185703100a18042002280130013801\" ) public { } } As you can see, the contract contains the byte code for the request you just wrote, exported as a Solidity contract that you can then import and instantiate from your own contracts. The next step is to write your main consumer contract . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"5. Compile the request"},{"location":"tutorials/bitcoin-price-feed/contract/","text":"6. Write your consumer contract that will handle price feed updates \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Plan the contract \u00b6 Your contract will maintain a public variable in its state that will contain the price of a bitcoin in US Dollars. An update of the price point can be requested on demand by any interested party: Anyone will be able to call a requestUpdate method in the contract that creates a new instance of the BitcoinPrice.sol contract and send it to Witnet. Once the request is resolved, anyone will be able to call the completeUpdate and write the result into the contract state. Initialize a basic contract \u00b6 Let's start by creating a bare-bones contract and saving it as contracts/PriceFeed.sol : pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // Allows logging errors event Error ( uint64 , string ); // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } } The above will: Import UsingWitnet.sol so your contract is Witnet-enabled. Import BitcoinPrice.sol so that you can instantiate the Witnet request when necessary. Make your contract inherit UsingWitnet . Make the constructor receive the address of the Witnet Bridge Interface ( _wbi ) and pass it down to the UsingWitnet constructor through UsingWitnet(_wbi) Write the requestUpdate method that launches the Witnet request \u00b6 function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 szabo ; // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 szabo ; // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); } Write the resolveUpdate method that reads the result of the Witnet request \u00b6 // The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows you to // protect your methods from being called before the request has been successfully // relayed into Witnet. function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, log the error message if ( result . isOk ()) { bitcoinPrice = result . asInt128 (); } else { ( Witnet . ErrorCodes errorCode , string memory errorMessage ) = result . asErrorMessage (); emit Error ( uint64 ( errorCode ), errorMessage ); } // In either case, set `pending` to false so a new update can be requested pending = false ; } Quick recap \u00b6 This is what the complete contract looks like: pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // Allow logging errors event Error ( uint64 , string ); // This constructor carries out a clever trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 szabo ; // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 szabo ; // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); } // The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows you to // protect your methods from being called before the request has been successfully // relayed into Witnet. function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, log the error message if ( result . isOk ()) { bitcoinPrice = result . asInt128 (); } else { ( Witnet . ErrorCodes errorCode , string memory errorMessage ) = result . asErrorMessage (); emit Error ( uint64 ( errorCode ), errorMessage ); } // In any case, set `pending` to false so a new update can be requested pending = false ; } } We can now prepare to deploy ! Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"6. Write the Solidity contract"},{"location":"tutorials/bitcoin-price-feed/contract/#6-write-your-consumer-contract-that-will-handle-price-feed-updates","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"6. Write your consumer contract that will handle price feed updates"},{"location":"tutorials/bitcoin-price-feed/contract/#plan-the-contract","text":"Your contract will maintain a public variable in its state that will contain the price of a bitcoin in US Dollars. An update of the price point can be requested on demand by any interested party: Anyone will be able to call a requestUpdate method in the contract that creates a new instance of the BitcoinPrice.sol contract and send it to Witnet. Once the request is resolved, anyone will be able to call the completeUpdate and write the result into the contract state.","title":"Plan the contract"},{"location":"tutorials/bitcoin-price-feed/contract/#initialize-a-basic-contract","text":"Let's start by creating a bare-bones contract and saving it as contracts/PriceFeed.sol : pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // Allows logging errors event Error ( uint64 , string ); // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } } The above will: Import UsingWitnet.sol so your contract is Witnet-enabled. Import BitcoinPrice.sol so that you can instantiate the Witnet request when necessary. Make your contract inherit UsingWitnet . Make the constructor receive the address of the Witnet Bridge Interface ( _wbi ) and pass it down to the UsingWitnet constructor through UsingWitnet(_wbi)","title":"Initialize a basic contract"},{"location":"tutorials/bitcoin-price-feed/contract/#write-the-requestupdate-method-that-launches-the-witnet-request","text":"function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 szabo ; // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 szabo ; // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); }","title":"Write the requestUpdate method that launches the Witnet request"},{"location":"tutorials/bitcoin-price-feed/contract/#write-the-resolveupdate-method-that-reads-the-result-of-the-witnet-request","text":"// The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows you to // protect your methods from being called before the request has been successfully // relayed into Witnet. function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, log the error message if ( result . isOk ()) { bitcoinPrice = result . asInt128 (); } else { ( Witnet . ErrorCodes errorCode , string memory errorMessage ) = result . asErrorMessage (); emit Error ( uint64 ( errorCode ), errorMessage ); } // In either case, set `pending` to false so a new update can be requested pending = false ; }","title":"Write the resolveUpdate method that reads the result of the Witnet request"},{"location":"tutorials/bitcoin-price-feed/contract/#quick-recap","text":"This is what the complete contract looks like: pragma solidity ^ 0.5.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { int128 public bitcoinPrice ; // The public Bitcoin price point uint256 lastRequestId ; // Stores the ID of the last Witnet request bool pending ; // Tells if an update has been requested but not yet completed Request request ; // The Witnet request object, is set in the constructor // Allow logging errors event Error ( uint64 , string ); // This constructor carries out a clever trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( address _wbi ) UsingWitnet ( _wbi ) public { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } function requestUpdate () public payable { require ( ! pending , \"An update is already pending. Complete it first before requesting another update.\" ); // Amount to pay to the bridge node relaying this request from Ethereum to Witnet uint256 _witnetRequestReward = 100 szabo ; // Amount of wei to pay to the bridge node relaying the result from Witnet to Ethereum uint256 _witnetResultReward = 100 szabo ; // Send the request to Witnet and store the ID for later retrieval of the result // The `witnetPostRequest` method comes with `UsingWitnet` lastRequestId = witnetPostRequest ( request , _witnetRequestReward , _witnetResultReward ); } // The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows you to // protect your methods from being called before the request has been successfully // relayed into Witnet. function completeUpdate () public payable witnetRequestAccepted ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, log the error message if ( result . isOk ()) { bitcoinPrice = result . asInt128 (); } else { ( Witnet . ErrorCodes errorCode , string memory errorMessage ) = result . asErrorMessage (); emit Error ( uint64 ( errorCode ), errorMessage ); } // In any case, set `pending` to false so a new update can be requested pending = false ; } } We can now prepare to deploy ! Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Quick recap"},{"location":"tutorials/bitcoin-price-feed/create-project/","text":"1. Create a new Witnet-enabled project \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Using the Witnet Truffle Box \u00b6 If you are creating a new project from scratch, the quickest way to get things working is using Truffle to download a Witnet-enabled project template: GNU/Linux, Mac OS or Linux Subsystem for Windows mkdir bitcoin-price-feed cd bitcoin-price-feed truffle unbox witnet/truffle-box You can keep reading this page to learn more about the Truffle box boilerplate, but if you are feeling impatient you can jump straight to defining data sources . Project folder structure \u00b6 After unboxing you should find yourself in a project that has been populated with the following directory structure: bitcoin-price-feed \u251c\u2500\u2500 contracts // Where your Solidity contracts will be \u2502 \u2514\u2500\u2500 requests // Where Witnet requests end up after compilation \u251c\u2500\u2500 migrations // Deployment scripts \u251c\u2500\u2500 requests // Witnet request source code (.js files) \u2514\u2500\u2500 test // Scripts for testing your contracts Next step: adding data sources \u00b6 You are now ready to move forward into defining the data sources to be used . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"1. Create a new project"},{"location":"tutorials/bitcoin-price-feed/create-project/#1-create-a-new-witnet-enabled-project","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"1. Create a new Witnet-enabled project"},{"location":"tutorials/bitcoin-price-feed/create-project/#using-the-witnet-truffle-box","text":"If you are creating a new project from scratch, the quickest way to get things working is using Truffle to download a Witnet-enabled project template: GNU/Linux, Mac OS or Linux Subsystem for Windows mkdir bitcoin-price-feed cd bitcoin-price-feed truffle unbox witnet/truffle-box You can keep reading this page to learn more about the Truffle box boilerplate, but if you are feeling impatient you can jump straight to defining data sources .","title":"Using the Witnet Truffle Box"},{"location":"tutorials/bitcoin-price-feed/create-project/#project-folder-structure","text":"After unboxing you should find yourself in a project that has been populated with the following directory structure: bitcoin-price-feed \u251c\u2500\u2500 contracts // Where your Solidity contracts will be \u2502 \u2514\u2500\u2500 requests // Where Witnet requests end up after compilation \u251c\u2500\u2500 migrations // Deployment scripts \u251c\u2500\u2500 requests // Witnet request source code (.js files) \u2514\u2500\u2500 test // Scripts for testing your contracts","title":"Project folder structure"},{"location":"tutorials/bitcoin-price-feed/create-project/#next-step-adding-data-sources","text":"You are now ready to move forward into defining the data sources to be used . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Next step: adding data sources"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/","text":"4. Put everything together and fine-tune the Witnet request \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Put everything together \u00b6 Time to put everything together and create the Witnet.Request object that you will need to export: // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 4 , 2 ) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } The .setQuorum , .setFees and .schedule methods are explained below. Fine-tune fees, quorum and schedule \u00b6 Witnet requests are highly parameterizable. You can fine-tune almost every single aspect of their life cycle: .setQuorum () sets how many Witnet nodes will be \"hired\" for resolving the request. .setFees () specifies how much you want to pay for rewarding each of the Witnet nodes implicated in resolving the request. .schedule () schedules the request to be resolved in a particular date and time in the future. Set the quorum \u00b6 . setQuorum ( witnesses , backup_witnesses ) The witnesses is the minimum number of Witnet nodes that will be resolving each specific request. In general, the higher the number of witnesses, the safer the request. However, a higher number of witnesses generally means higher fees. The actual number of nodes that will resolve each request is guaranteed to be equal to the specified number. If for some reason the network fails to assign the request to enough nodes, it will be reassigned in every subsequent epoch to a different randomly-selected set of nodes until the required number is reached. The backup_witnesses is the number of Witnet nodes that will be used as a backup in case some of the originally assigned nodes fail to fulfill their commitments. A higher backup_witnesses value corresponds with higher fees but also guarantees that the request will be resolved in a timely fashion. On the other hand, a small backup_witnesses value comes with the risk that your request will need to be retried many times and therefore the result may be potentially inaccurate (especially if the queried data point changes rapidly). Optional arguments for .setQuorum \u00b6 The .setQuorum method accepts three more optional arguments: . setQuorum ( witnesses , backup_witnesses , extra_commit_rounds , extra_reveal_rounds , minimum_consensus ) The extra_commit_rounds number specifies how many extra epochs Witnet nodes will be given for committing their partial results. A number greater than 0 strengthens the chances of a Witnet request being resolved to a value instead of timing out. This parameter is actually an upper threshold, i.e. the request will progress into a reveal stage as soon as the number of commitments equals the number of required witnesses. If not set, this parameter defaults to 1 . This parameter has no impact on the price of the request. The extra_reveal_rounds number specifies how many extra epochs Witnet nodes will be given to reveal their partial results. A number greater than 0 strengthens the security of a Witnet request by preventing miners from withholding reveal transactions\u2014as the subsequent miners can include any reveal transactions withheld by a former miner. This parameter is actually an upper threshold, i.e. the request will be tallied and finalized as soon as the number of reveals equals the number of commitments. If not set, this parameter defaults to 1 . This parameter has no impact on the price of the request. The minimum_consensus percentage allows users to define a threshold for aborting resolution of a request if the witnessing nodes did not arrive at broad consensus. That is, aggregator and tally functions will not be applied if the ratio of valid values vs. errors is below this threshold. E.g. a minimum_consensus threshold of 70 requires 70% of the witnesses to report a valid value, otherwise the request will result in an error, stating \"insufficient consensus\" . If not set, this parameter defaults to 51 . Set the fees \u00b6 . setFees ( reward , commit_fee , reveal_fee , tally_fee ) Witnet allows parametrization of many of the economic incentives that affect the life cycle of your requests. These incentives include: request_fee : the amount of wit tokens that will be earned by the Witnet miner that publishes your request in a block. reward : the amount of wit tokens that each of the Witnet nodes assigned to your request will earn if they honestly fulfill their commitments and reveals. commit_fee : the amount of wit tokens that will be earned by Witnet miners for each each valid commitment transaction they include in a block. reveal_fee : the amount of wit tokens that will be earned by Witnet miners for each valid reveal transaction they include in a block. tally_fee : the amount of wit tokens that will be earned by the Witnet miner that publishes the tally of all the reveal transactions related to your request in a block. How can I compute the total cost of a request? The total cost of a Witnet request equals: request_fee + witnesses * (reward + commit_fee + reveal_fee) + tally_fee There are two special cases in which some fees are automatically refunded to the requester upon an eventual tally: For every valid reveal that later does not pass the filters in the tally stage (aka outliers ), you get reward back. For every missing reveal after the extra_reveal_rounds threshold is reached, you get reward + reveal_fee back. Set the schedule \u00b6 . schedule ( timestamp ) Witnet requests can be scheduled for resolution on a particular date and time in the future. Timestamps need to be provided as POSIX timestamps , i.e. seconds elapsed from 00:00:00 UTC on 1 January 1970 until the desired date. Double check \u00b6 Time to double check everything is fine. Your BitcoinPrice.js file should look more or less like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.0 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregator function . setTally ( tally ) // Set the tally function . setQuorum ( 4 , 2 ,) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } Time to go ahead and compile the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"4. Fine-tune the request"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#4-put-everything-together-and-fine-tune-the-witnet-request","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"4. Put everything together and fine-tune the Witnet request"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#put-everything-together","text":"Time to put everything together and create the Witnet.Request object that you will need to export: // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 4 , 2 ) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } The .setQuorum , .setFees and .schedule methods are explained below.","title":"Put everything together"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#fine-tune-fees-quorum-and-schedule","text":"Witnet requests are highly parameterizable. You can fine-tune almost every single aspect of their life cycle: .setQuorum () sets how many Witnet nodes will be \"hired\" for resolving the request. .setFees () specifies how much you want to pay for rewarding each of the Witnet nodes implicated in resolving the request. .schedule () schedules the request to be resolved in a particular date and time in the future.","title":"Fine-tune fees, quorum and schedule"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-quorum","text":". setQuorum ( witnesses , backup_witnesses ) The witnesses is the minimum number of Witnet nodes that will be resolving each specific request. In general, the higher the number of witnesses, the safer the request. However, a higher number of witnesses generally means higher fees. The actual number of nodes that will resolve each request is guaranteed to be equal to the specified number. If for some reason the network fails to assign the request to enough nodes, it will be reassigned in every subsequent epoch to a different randomly-selected set of nodes until the required number is reached. The backup_witnesses is the number of Witnet nodes that will be used as a backup in case some of the originally assigned nodes fail to fulfill their commitments. A higher backup_witnesses value corresponds with higher fees but also guarantees that the request will be resolved in a timely fashion. On the other hand, a small backup_witnesses value comes with the risk that your request will need to be retried many times and therefore the result may be potentially inaccurate (especially if the queried data point changes rapidly).","title":"Set the quorum"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#optional-arguments-for-setquorum","text":"The .setQuorum method accepts three more optional arguments: . setQuorum ( witnesses , backup_witnesses , extra_commit_rounds , extra_reveal_rounds , minimum_consensus ) The extra_commit_rounds number specifies how many extra epochs Witnet nodes will be given for committing their partial results. A number greater than 0 strengthens the chances of a Witnet request being resolved to a value instead of timing out. This parameter is actually an upper threshold, i.e. the request will progress into a reveal stage as soon as the number of commitments equals the number of required witnesses. If not set, this parameter defaults to 1 . This parameter has no impact on the price of the request. The extra_reveal_rounds number specifies how many extra epochs Witnet nodes will be given to reveal their partial results. A number greater than 0 strengthens the security of a Witnet request by preventing miners from withholding reveal transactions\u2014as the subsequent miners can include any reveal transactions withheld by a former miner. This parameter is actually an upper threshold, i.e. the request will be tallied and finalized as soon as the number of reveals equals the number of commitments. If not set, this parameter defaults to 1 . This parameter has no impact on the price of the request. The minimum_consensus percentage allows users to define a threshold for aborting resolution of a request if the witnessing nodes did not arrive at broad consensus. That is, aggregator and tally functions will not be applied if the ratio of valid values vs. errors is below this threshold. E.g. a minimum_consensus threshold of 70 requires 70% of the witnesses to report a valid value, otherwise the request will result in an error, stating \"insufficient consensus\" . If not set, this parameter defaults to 51 .","title":"Optional arguments for .setQuorum"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-fees","text":". setFees ( reward , commit_fee , reveal_fee , tally_fee ) Witnet allows parametrization of many of the economic incentives that affect the life cycle of your requests. These incentives include: request_fee : the amount of wit tokens that will be earned by the Witnet miner that publishes your request in a block. reward : the amount of wit tokens that each of the Witnet nodes assigned to your request will earn if they honestly fulfill their commitments and reveals. commit_fee : the amount of wit tokens that will be earned by Witnet miners for each each valid commitment transaction they include in a block. reveal_fee : the amount of wit tokens that will be earned by Witnet miners for each valid reveal transaction they include in a block. tally_fee : the amount of wit tokens that will be earned by the Witnet miner that publishes the tally of all the reveal transactions related to your request in a block. How can I compute the total cost of a request? The total cost of a Witnet request equals: request_fee + witnesses * (reward + commit_fee + reveal_fee) + tally_fee There are two special cases in which some fees are automatically refunded to the requester upon an eventual tally: For every valid reveal that later does not pass the filters in the tally stage (aka outliers ), you get reward back. For every missing reveal after the extra_reveal_rounds threshold is reached, you get reward + reveal_fee back.","title":"Set the fees"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-schedule","text":". schedule ( timestamp ) Witnet requests can be scheduled for resolution on a particular date and time in the future. Timestamps need to be provided as POSIX timestamps , i.e. seconds elapsed from 00:00:00 UTC on 1 January 1970 until the desired date.","title":"Set the schedule"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#double-check","text":"Time to double check everything is fine. Your BitcoinPrice.js file should look more or less like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.0 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregator function . setTally ( tally ) // Set the tally function . setQuorum ( 4 , 2 ,) // Set witness count . setFees ( 10 , 1 , 1 , 1 ) // Set economic incentives . schedule ( 0 ) // Make this request immediately solvable // Do not forget to export the request object export { request as default } Time to go ahead and compile the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Double check"},{"location":"tutorials/bitcoin-price-feed/introduction/","text":"Basic Witnet tutorial: how to create a decentralized Bitcoin price feed on Ethereum with Solidity and Witnet \u00b6 What and why? \u00b6 In this tutorial you will: Query two different APIs for the USD price of 1 bitcoin using 4 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be trustlessly consumed by an Ethereum smart contract. Write a Solidity contract that keeps the bitcoin price in a public variable and handles updates using Witnet. Compile and deploy the entire flow into a local Ethereum network. Remember: using Witnet from Ethereum is particularly convenient because you do not need to own or pay any wit tokens: you pay the bridge nodes using ETH and then they spend their own wit tokens when posting your requests into Witnet in your behalf. How decentralized will this price feed be? \u00b6 None of the parties involved in the process of deploying, updating and using the price feed will have any power to tamper with the integrity of the data points it provides: Once deployed, no one will be able to prevent the price feed from being updated or queried . Nobody can set the price directly . The only way to update it is through a Witnet request. The price is averaged from two different public APIs, thus mitigating their influence in the final price. The data is relayed by 4 different Witnet nodes, whose reported data points are aggregated and averaged, filtering out any outliers so as to cancel any malicious reporter who may try to leverage a slight drift of the data point. What will the code look like? \u00b6 The final result of this tutorial is available in this GitHub repository . You can also check it out with Truffle: mkdir PriceFeed cd PriceFeed truffle unbox stampery-labs/witnet-pricefeed-example Ready to start? \u00b6 Let's begin by creating a new Witnet-enabled Solidity project . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Introduction"},{"location":"tutorials/bitcoin-price-feed/introduction/#basic-witnet-tutorial-how-to-create-a-decentralized-bitcoin-price-feed-on-ethereum-with-solidity-and-witnet","text":"","title":"Basic Witnet tutorial: how to create a decentralized Bitcoin price feed on Ethereum with Solidity and Witnet"},{"location":"tutorials/bitcoin-price-feed/introduction/#what-and-why","text":"In this tutorial you will: Query two different APIs for the USD price of 1 bitcoin using 4 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be trustlessly consumed by an Ethereum smart contract. Write a Solidity contract that keeps the bitcoin price in a public variable and handles updates using Witnet. Compile and deploy the entire flow into a local Ethereum network. Remember: using Witnet from Ethereum is particularly convenient because you do not need to own or pay any wit tokens: you pay the bridge nodes using ETH and then they spend their own wit tokens when posting your requests into Witnet in your behalf.","title":"What and why?"},{"location":"tutorials/bitcoin-price-feed/introduction/#how-decentralized-will-this-price-feed-be","text":"None of the parties involved in the process of deploying, updating and using the price feed will have any power to tamper with the integrity of the data points it provides: Once deployed, no one will be able to prevent the price feed from being updated or queried . Nobody can set the price directly . The only way to update it is through a Witnet request. The price is averaged from two different public APIs, thus mitigating their influence in the final price. The data is relayed by 4 different Witnet nodes, whose reported data points are aggregated and averaged, filtering out any outliers so as to cancel any malicious reporter who may try to leverage a slight drift of the data point.","title":"How decentralized will this price feed be?"},{"location":"tutorials/bitcoin-price-feed/introduction/#what-will-the-code-look-like","text":"The final result of this tutorial is available in this GitHub repository . You can also check it out with Truffle: mkdir PriceFeed cd PriceFeed truffle unbox stampery-labs/witnet-pricefeed-example","title":"What will the code look like?"},{"location":"tutorials/bitcoin-price-feed/introduction/#ready-to-start","text":"Let's begin by creating a new Witnet-enabled Solidity project . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Ready to start?"},{"location":"tutorials/bitcoin-price-feed/migrations/","text":"7. Migrate the contracts into an Ethereum network \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Compile your Solidity contract \u00b6 First off, run the compile command, which compiles your Solidity contracts and then recompiles the Witnet requests: npm npm run compile yarn yarn compile You have migration scripts by default! \u00b6 Migration scripts are very useful in Truffle. They allow you to configure how your contracts will be deployed on different Ethereum networks, set your contract's constructor arguments and link dynamic dependencies. In addition to compiling your requests into Solidity, the Witnet request compiler that lives inside the Truffle box also wrote autogenerated migration scripts for your contracts . If you look at the migrations folder, you should find these three files: 1_initial_migration.js : basic Truffle infrastructure migrations. 2_witnet_core.js : deploys all the Witnet-related contracts if you are deploying on a local or private network; or dynamically links them if you are on a public network (Ethereum Mainnet, Rinkeby or G\u00f6rli). 3_user_contracts.js : contains autogenerated migration scripts for your consumer contracts. Let's take a look at migrations/3_user_contracts.js : // This file was auto-generated by the Witnet compiler; any manual changes will be overwritten except // for the contracts' constructor arguments (you can freely edit those and the compiler will respect them). const Witnet = artifacts . require ( \"Witnet\" ) const WitnetRequestsBoardProxy = artifacts . require ( \"WitnetRequestsBoardProxy\" ) const PriceFeed = artifacts . require ( \"PriceFeed\" ) module . exports = function ( deployer ) { deployer . link ( Witnet , [ PriceFeed ]) deployer . deploy ( PriceFeed , WitnetRequestsBoardProxy . address ) } As you can see, the autogenerated migration script is: Dynamically linking the Witnet library to your PriceFeed contract. Deploying your PriceFeed contract. Passing the address of the Witnet Bridge Interface to the PriceFeed constructor. For the compiler to pass the address of the Witnet Bridge Interface to all your consumer contracts, it is important that they have a constructor argument called _wbi , just like PriceFeed has. Customize the constructor arguments \u00b6 If your consumer contract has additional constructor arguments, the compiler will create default values for them. Before running any migration, please make sure you double-check the default arguments that the compiler inserts for you, as they may not make any sense for your specific use case. Once you modify any constructor arguments, the compiler will not rewrite those lines. If you mess them up or you want the compiler to generate default values for new constructor arguments, you can just delete those lines or remove the 3_user_contracts.js file altogether, then run the compiler once again. Run the deployment \u00b6 Deploying your contract into Truffle's own local Ethereum network is as simple as executing: truffle migrate Please take into account that Truffle's own local network lacks any bridging capability with Witnet. This means that it is good for testing the migrations, but not for testing the entire workflow of your contracts. However, the Witnet community is working hard to overcome this limitation so that you can test your Witnet-connected contracts locally. If you want to test your contracts in a more realistic environment, you can deploy them into a public network using the --network flag: truffle migrate --network=rinkeby deploys on the Ethereum Rinkeby testnet. truffle migrate --network=goerli deploys on the Ethereum G\u00f6rli testnet. Deploying on Mainnet is not supported yet. Take a look at the community roadmap for more information on Mainnet support. Interact with your contract \u00b6 The Truffle documentation has a comprehensive guide on interacting with your contracts . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"7. Deploy"},{"location":"tutorials/bitcoin-price-feed/migrations/#7-migrate-the-contracts-into-an-ethereum-network","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"7. Migrate the contracts into an Ethereum network"},{"location":"tutorials/bitcoin-price-feed/migrations/#compile-your-solidity-contract","text":"First off, run the compile command, which compiles your Solidity contracts and then recompiles the Witnet requests: npm npm run compile yarn yarn compile","title":"Compile your Solidity contract"},{"location":"tutorials/bitcoin-price-feed/migrations/#you-have-migration-scripts-by-default","text":"Migration scripts are very useful in Truffle. They allow you to configure how your contracts will be deployed on different Ethereum networks, set your contract's constructor arguments and link dynamic dependencies. In addition to compiling your requests into Solidity, the Witnet request compiler that lives inside the Truffle box also wrote autogenerated migration scripts for your contracts . If you look at the migrations folder, you should find these three files: 1_initial_migration.js : basic Truffle infrastructure migrations. 2_witnet_core.js : deploys all the Witnet-related contracts if you are deploying on a local or private network; or dynamically links them if you are on a public network (Ethereum Mainnet, Rinkeby or G\u00f6rli). 3_user_contracts.js : contains autogenerated migration scripts for your consumer contracts. Let's take a look at migrations/3_user_contracts.js : // This file was auto-generated by the Witnet compiler; any manual changes will be overwritten except // for the contracts' constructor arguments (you can freely edit those and the compiler will respect them). const Witnet = artifacts . require ( \"Witnet\" ) const WitnetRequestsBoardProxy = artifacts . require ( \"WitnetRequestsBoardProxy\" ) const PriceFeed = artifacts . require ( \"PriceFeed\" ) module . exports = function ( deployer ) { deployer . link ( Witnet , [ PriceFeed ]) deployer . deploy ( PriceFeed , WitnetRequestsBoardProxy . address ) } As you can see, the autogenerated migration script is: Dynamically linking the Witnet library to your PriceFeed contract. Deploying your PriceFeed contract. Passing the address of the Witnet Bridge Interface to the PriceFeed constructor. For the compiler to pass the address of the Witnet Bridge Interface to all your consumer contracts, it is important that they have a constructor argument called _wbi , just like PriceFeed has.","title":"You have migration scripts by default!"},{"location":"tutorials/bitcoin-price-feed/migrations/#customize-the-constructor-arguments","text":"If your consumer contract has additional constructor arguments, the compiler will create default values for them. Before running any migration, please make sure you double-check the default arguments that the compiler inserts for you, as they may not make any sense for your specific use case. Once you modify any constructor arguments, the compiler will not rewrite those lines. If you mess them up or you want the compiler to generate default values for new constructor arguments, you can just delete those lines or remove the 3_user_contracts.js file altogether, then run the compiler once again.","title":"Customize the constructor arguments"},{"location":"tutorials/bitcoin-price-feed/migrations/#run-the-deployment","text":"Deploying your contract into Truffle's own local Ethereum network is as simple as executing: truffle migrate Please take into account that Truffle's own local network lacks any bridging capability with Witnet. This means that it is good for testing the migrations, but not for testing the entire workflow of your contracts. However, the Witnet community is working hard to overcome this limitation so that you can test your Witnet-connected contracts locally. If you want to test your contracts in a more realistic environment, you can deploy them into a public network using the --network flag: truffle migrate --network=rinkeby deploys on the Ethereum Rinkeby testnet. truffle migrate --network=goerli deploys on the Ethereum G\u00f6rli testnet. Deploying on Mainnet is not supported yet. Take a look at the community roadmap for more information on Mainnet support.","title":"Run the deployment"},{"location":"tutorials/bitcoin-price-feed/migrations/#interact-with-your-contract","text":"The Truffle documentation has a comprehensive guide on interacting with your contracts . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Interact with your contract"},{"location":"tutorials/bitcoin-price-feed/recap/","text":"Quick recap on what you've built \u00b6 Congratulations! You've now built your first Solidity contract using Witnet to trustlessly consume external APIs. What will you build next? Join the Witnet Community Discord or Telegram groups and let us know any ideas or suggestions you have.","title":"Recap"},{"location":"tutorials/bitcoin-price-feed/recap/#quick-recap-on-what-youve-built","text":"Congratulations! You've now built your first Solidity contract using Witnet to trustlessly consume external APIs. What will you build next? Join the Witnet Community Discord or Telegram groups and let us know any ideas or suggestions you have.","title":"Quick recap on what you've built"},{"location":"tutorials/bitcoin-price-feed/sources/","text":"2. Choose and add data sources for the price feed \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. A quick intro on Witnet data sources \u00b6 Data sources are each of the endpoints from which you want Witnet to retrieve the data . Most of the time, these will be the URLs of public APIs. There is no limit to the number of sources in a single Witnet request \u2014 although the more sources, the higher the fees will be. Each source can have a companion script that lists the operations we want the witnesses to apply on the retrieved data. This enables you to get the information of your interest extracted out of larger data structures like JSON objects. Choose your sources carefully \u00b6 Just like your friends\u2014and your enemies\u2014your data sources need to be chosen wisely . The Garbage In, Garbage Out principle applies here. Regardless of the many checks-and-balances , well-designed incentives and security measures that the Witnet protocol implements, if the data sources in your Witnet requests are not reliable, your contracts won't be either. The more reliable data sources you list, the more trust-mitigated your Witnet requests will become. In other words, your contracts will be more resilient to downtime, failure or corruption of each separate source. Introducing smart data sources \u00b6 The scripting language used in Witnet requests is very flexible: in addition to selecting specific pieces of data, you can also transform them so they are uniform and can be compared or aggregated together. For example, imagine a request that queries weather data. One source may use Celsius and the other may use Fahrenheit. You can tell Witnet to transform them both to Celcius so they can be averaged. In this tutorial, you will be defining two data sources \u2014 one querying Bitstamp and the other for CoinDesk : Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, so more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key A few things worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator, just as you would expect from Javascript method chaining or the builder pattern . Source scripts always start with a String 1 . Key-value data structures (roughly similar to Javascript objects , Python dictionaries or Solidity mappings ) are called maps . Values in maps cannot be accessed directly by name as .keyName but instead through a call to one of the .getArray ( \"keyName\" ) , .getBoolean ( \"keyName\" ) , .getInteger ( \"keyName\" ) , .getFloat ( \"keyName\" ) , .getInteger ( \"keyName\" ) , .getMap ( \"keyName\" ) or .getString ( \"keyName\" ) operators. The final return type of a script is that of its last operator. For any combination of known input type and RADON script, the output type can be easily guessed upon compilation. All source scripts MUST return exactly the same type ( Float in this case). Where do I put the sources? \u00b6 Let's create a new requests/BitcoinPrice.js file and copy the two example sources above into it: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key Notice the import instruction at the top, which makes it possible to use all the tools that the Witnet Javascript library provides: import * as Witnet from \"witnet-requests\" Please make sure you save the requests/BitcoinPrice.js file. Next step: define aggregator and tally functions \u00b6 You are done with the sources for now. Let's move forward into defining the aggregation and tally functions . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial. In future versions, the Witnet protocol will make no assumptions on what the data type of the server response will be for different data sources. This will allow for formats other than plain text, such as multimedia files and any kind of binaries. Therefore, source scripts will start with Bytes as the input type; it will be totally up to the requester to specify whether those bytes should be interpreted as a String , Integer etc. \u21a9 One of the key features in RADON 2.0 will be implicit type casting, which will dramatically reduce the size of scripts. \u21a9","title":"2. Adding data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#2-choose-and-add-data-sources-for-the-price-feed","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"2. Choose and add data sources for the price feed"},{"location":"tutorials/bitcoin-price-feed/sources/#a-quick-intro-on-witnet-data-sources","text":"Data sources are each of the endpoints from which you want Witnet to retrieve the data . Most of the time, these will be the URLs of public APIs. There is no limit to the number of sources in a single Witnet request \u2014 although the more sources, the higher the fees will be. Each source can have a companion script that lists the operations we want the witnesses to apply on the retrieved data. This enables you to get the information of your interest extracted out of larger data structures like JSON objects.","title":"A quick intro on Witnet data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#choose-your-sources-carefully","text":"Just like your friends\u2014and your enemies\u2014your data sources need to be chosen wisely . The Garbage In, Garbage Out principle applies here. Regardless of the many checks-and-balances , well-designed incentives and security measures that the Witnet protocol implements, if the data sources in your Witnet requests are not reliable, your contracts won't be either. The more reliable data sources you list, the more trust-mitigated your Witnet requests will become. In other words, your contracts will be more resilient to downtime, failure or corruption of each separate source.","title":"Choose your sources carefully"},{"location":"tutorials/bitcoin-price-feed/sources/#introducing-smart-data-sources","text":"The scripting language used in Witnet requests is very flexible: in addition to selecting specific pieces of data, you can also transform them so they are uniform and can be compared or aggregated together. For example, imagine a request that queries weather data. One source may use Celsius and the other may use Fahrenheit. You can tell Witnet to transform them both to Celcius so they can be averaged. In this tutorial, you will be defining two data sources \u2014 one querying Bitstamp and the other for CoinDesk : Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, so more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key A few things worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator, just as you would expect from Javascript method chaining or the builder pattern . Source scripts always start with a String 1 . Key-value data structures (roughly similar to Javascript objects , Python dictionaries or Solidity mappings ) are called maps . Values in maps cannot be accessed directly by name as .keyName but instead through a call to one of the .getArray ( \"keyName\" ) , .getBoolean ( \"keyName\" ) , .getInteger ( \"keyName\" ) , .getFloat ( \"keyName\" ) , .getInteger ( \"keyName\" ) , .getMap ( \"keyName\" ) or .getString ( \"keyName\" ) operators. The final return type of a script is that of its last operator. For any combination of known input type and RADON script, the output type can be easily guessed upon compilation. All source scripts MUST return exactly the same type ( Float in this case).","title":"Introducing smart data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#where-do-i-put-the-sources","text":"Let's create a new requests/BitcoinPrice.js file and copy the two example sources above into it: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseMapJSON () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key Notice the import instruction at the top, which makes it possible to use all the tools that the Witnet Javascript library provides: import * as Witnet from \"witnet-requests\" Please make sure you save the requests/BitcoinPrice.js file.","title":"Where do I put the sources?"},{"location":"tutorials/bitcoin-price-feed/sources/#next-step-define-aggregator-and-tally-functions","text":"You are done with the sources for now. Let's move forward into defining the aggregation and tally functions . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial. In future versions, the Witnet protocol will make no assumptions on what the data type of the server response will be for different data sources. This will allow for formats other than plain text, such as multimedia files and any kind of binaries. Therefore, source scripts will start with Bytes as the input type; it will be totally up to the requester to specify whether those bytes should be interpreted as a String , Integer etc. \u21a9 One of the key features in RADON 2.0 will be implicit type casting, which will dramatically reduce the size of scripts. \u21a9","title":"Next step: define aggregator and tally functions"}]}