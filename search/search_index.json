{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Witnet ecosystem! \u00b6 The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information in behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central for incentivizing the network players to abide by the protocol and make them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum . Node operators, a.k.a. Witnesses \u00b6 The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts. Developers \u00b6 The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet . Contribute to Witnet-Rust or Sheikah . Witnet Foundation \u00b6 Witnet Foundation is the independent entity currently in charge of funding the development of Witnet-Rust and Sheikah, as well as fostering the thriving ecosystem around the Witnet protocol. Other stakeholders \u00b6 The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many things you can do to spread the word!","title":"Ecosystem"},{"location":"#welcome-to-the-witnet-ecosystem","text":"The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information in behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central for incentivizing the network players to abide by the protocol and make them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum .","title":"Welcome to the Witnet ecosystem!"},{"location":"#node-operators-aka-witnesses","text":"The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts.","title":"Node operators, a.k.a. Witnesses"},{"location":"#developers","text":"The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet . Contribute to Witnet-Rust or Sheikah .","title":"Developers"},{"location":"#witnet-foundation","text":"Witnet Foundation is the independent entity currently in charge of funding the development of Witnet-Rust and Sheikah, as well as fostering the thriving ecosystem around the Witnet protocol.","title":"Witnet Foundation"},{"location":"#other-stakeholders","text":"The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many things you can do to spread the word!","title":"Other stakeholders"},{"location":"community/contributing/","text":"Contributing to Witnet \u00b6 Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document. Code of conduct \u00b6 Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well. I just have a question \u00b6 Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response. How can I contribute? \u00b6 Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma. Reporting bugs \u00b6 This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having. How do I submit a good bug report? \u00b6 Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version? Suggesting enhancements \u00b6 This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible. How Do I Submit A Good Enhancement Suggestion? \u00b6 Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package. Your First Code Contribution \u00b6 Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two. Sending a Pull Request \u00b6 Commit messages convention \u00b6 We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat(mining): use a random nonce as input in mint transactions BREAKING CHANGE: former mint transactions containing no inputs will be rendered invalid refactor(config): make `config` actor return settings as `Option`s docs : add RADON ` FLOAT_TOSTRING ` opcode this operator converts any floating point number into a UTF8 string chore(cargo): upgrade `actix` to version 0.8.1 fix #503 PGP-signing your commits \u00b6 All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"Contributing"},{"location":"community/contributing/#contributing-to-witnet","text":"Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document.","title":"Contributing to Witnet"},{"location":"community/contributing/#code-of-conduct","text":"Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well.","title":"Code of conduct"},{"location":"community/contributing/#i-just-have-a-question","text":"Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response.","title":"I just have a question"},{"location":"community/contributing/#how-can-i-contribute","text":"Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma.","title":"How can I contribute?"},{"location":"community/contributing/#reporting-bugs","text":"This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having.","title":"Reporting bugs"},{"location":"community/contributing/#how-do-i-submit-a-good-bug-report","text":"Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version?","title":"How do I submit a good bug report?"},{"location":"community/contributing/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible.","title":"Suggesting enhancements"},{"location":"community/contributing/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package.","title":"How Do I Submit A Good Enhancement Suggestion?"},{"location":"community/contributing/#your-first-code-contribution","text":"Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two.","title":"Your First Code Contribution"},{"location":"community/contributing/#sending-a-pull-request","text":"","title":"Sending a Pull Request"},{"location":"community/contributing/#commit-messages-convention","text":"We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat(mining): use a random nonce as input in mint transactions BREAKING CHANGE: former mint transactions containing no inputs will be rendered invalid refactor(config): make `config` actor return settings as `Option`s docs : add RADON ` FLOAT_TOSTRING ` opcode this operator converts any floating point number into a UTF8 string chore(cargo): upgrade `actix` to version 0.8.1 fix #503","title":"Commit messages convention"},{"location":"community/contributing/#pgp-signing-your-commits","text":"All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"PGP-signing your commits"},{"location":"community/roadmap/","text":"Community Roadmap \u00b6 Witnet is an open initiative and Witnet-Rust and Sheikah are open source projects that are under development by an open community of organizations and independent developers. This means that no one can set the roadmap unilaterally. During the pre-mainnet phase, a subsequent testnet release is expected every to months, and each of them is a hard fork and full reset of the chain: [ Testnet-1 ] Jan 2019: basic protocol capabilities [ Testnet-2 ] Mar 2019: security and scalability improvements [ Testnet-3 ] May 2019: algorithmic reputation system [ Testnet-4 ] Jul 2019: Ethereum bridge [ Testnet-5 ] Sep 2019: mainnet readiness Given the experimental nature of the technologies and network protocols under development, these dates and deliverables may be subject to change due to reasons beyond the control of Witnet Foundation.","title":"Roadmap"},{"location":"community/roadmap/#community-roadmap","text":"Witnet is an open initiative and Witnet-Rust and Sheikah are open source projects that are under development by an open community of organizations and independent developers. This means that no one can set the roadmap unilaterally. During the pre-mainnet phase, a subsequent testnet release is expected every to months, and each of them is a hard fork and full reset of the chain: [ Testnet-1 ] Jan 2019: basic protocol capabilities [ Testnet-2 ] Mar 2019: security and scalability improvements [ Testnet-3 ] May 2019: algorithmic reputation system [ Testnet-4 ] Jul 2019: Ethereum bridge [ Testnet-5 ] Sep 2019: mainnet readiness Given the experimental nature of the technologies and network protocols under development, these dates and deliverables may be subject to change due to reasons beyond the control of Witnet Foundation.","title":"Community Roadmap"},{"location":"interfaces/cli/","text":"","title":"Command Line Interface"},{"location":"interfaces/json-rpc/","text":"","title":"Witnet-Rust JSON-RPC"},{"location":"interfaces/wallet-api/","text":"","title":"Wallet API"},{"location":"overview/concepts/","text":"What is Witnet? \u00b6 The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time. Smart Contracts Are Not What You Were Told \u00b6 Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom . Blockchain Oracles, And Their Problem \u00b6 Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" . The Solution: A Decentralized Oracle Network \u00b6 The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it. 100% Truth, 0% Trust \u00b6 Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"What is Witnet?"},{"location":"overview/concepts/#what-is-witnet","text":"The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Wait, what? Ok, lets go one step at a time.","title":"What is Witnet?"},{"location":"overview/concepts/#smart-contracts-are-not-what-you-were-told","text":"Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. Actually, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is: once they are created, no one can stop them from doing exactly what they were created for. They just obey their own source code, and censorship is just impossible. This is a really powerful idea. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom .","title":"Smart Contracts Are Not What You Were Told"},{"location":"overview/concepts/#blockchain-oracles-and-their-problem","text":"Given that smart contracts need to be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, there you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" .","title":"Blockchain Oracles, And Their Problem"},{"location":"overview/concepts/#the-solution-a-decentralized-oracle-network","text":"The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014which we fondly call witnesses \u2014who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved if a majority of them are incentivized to report the retrieved data honestly and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which is central to incentivizing the network players to abide by the protocol and make them liable for any misbehavior. Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data in behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not that expensive in terms of computation. The protocol has been conceived to ensure utmost decentralization and fairnes, so each witness' weight in the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the so-called miners are not actual human beings sitting in front of a computer, fulfilling assignments coming from an Internet overlord that commands them to use their web browser to navigate to a certain website and take a snapshot or copy some text that they must report. Indeed, the miners are just computers running a software (Witnet-rust) that automatically receive and execute a series of tasks without the owner of the computer having to actively do anything else than installing it.","title":"The Solution: A Decentralized Oracle Network"},{"location":"overview/concepts/#100-truth-0-trust","text":"Data retrieved, attested and delivered using the Witnet protocol is reliable not because of authority but because it comes from anonymous nodes who are incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The progressive reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not spotting fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"100% Truth, 0% Trust"},{"location":"overview/glossary/","text":"Glossary \u00b6 Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/glossary/#glossary","text":"Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/software/","text":"Witnet Software ecosystem \u00b6 Witnet-rust \u00b6 Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust is experimental software running on experimental network protocols: All the main components are in place\u2014but they need yet to be battle tested before mainnet. Testnet-4 is live. Here's the roadmap and this is how to run a node . The Witnet community is doing its best to make witnet-rust rock solid as soon as possible. [Contributions][contributing] are more than welcome. Sheikah \u00b6 Sheikah is a Witnet-compatible desktop wallet, data requests and smart contracts development environment. Ethereum Bridge \u00b6 The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is actually three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust, which monitors the WBI for new requests and also scans","title":"Software"},{"location":"overview/software/#witnet-software-ecosystem","text":"","title":"Witnet Software ecosystem"},{"location":"overview/software/#witnet-rust","text":"Witnet-rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust is experimental software running on experimental network protocols: All the main components are in place\u2014but they need yet to be battle tested before mainnet. Testnet-4 is live. Here's the roadmap and this is how to run a node . The Witnet community is doing its best to make witnet-rust rock solid as soon as possible. [Contributions][contributing] are more than welcome.","title":"Witnet-rust"},{"location":"overview/software/#sheikah","text":"Sheikah is a Witnet-compatible desktop wallet, data requests and smart contracts development environment.","title":"Sheikah"},{"location":"overview/software/#ethereum-bridge","text":"The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is actually three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust, which monitors the WBI for new requests and also scans","title":"Ethereum Bridge"},{"location":"protocol/blocks/","text":"","title":"Blocks"},{"location":"protocol/reputation/","text":"Reputation System \u00b6","title":"Reputation System"},{"location":"protocol/reputation/#reputation-system","text":"","title":"Reputation System"},{"location":"protocol/serialization/","text":"","title":"Serialization"},{"location":"protocol/sortition/","text":"","title":"Sortition"},{"location":"protocol/transactions/","text":"","title":"Transactions"},{"location":"protocol/data-requests/examples/","text":"Examples \u00b6 What's the weather in Berlin? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the OpenWeatherMap API that returns the current weather conditions in Berlin. Retrieval stage \u00b6 Javascript const openWeatherMaps = new Source ( \"https://openweathermap.org/data/2.5/weather?id=2950159&appid=b6907d289e10d714a6e88b30761fae22\" ) . asString () // Treat the response as a string of text (retrieval always starts with `Bytes`) . parseJSON () // Parse the string, which we now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"weather\" ) // Get the value associated to the `weather` key . asMap () // Treat that as a Javascript object too . get ( \"temp\" ) // Now get the value associated to the `weather` key . asFloat (); // Finally treat that as a floating point number RADON-AST [ BYTES_ASSTRING , STRING_PARSEJSON , MIXED_ASMAP , [ MAP_GET , \"weather\" ], MIXED_ASMAP , [ MAP_GET , \"temp\" ], MIXED_ASFLOAT ] RADON-JSON [ 117 , 69 , 116 , [ 97 , 'weather' ], 116 , [ 97 , 'temp' ], 114 ] CBOR (Base16) 87187518451874821861677765617468657218748218616474656 D701872 CBOR (Base64) hxh1GEUYdIIYYWd3ZWF0aGVyGHSCGGFkdGVtcBhy CBOR (Base65536) \u4c87\u4c75\u4c45\ud842\udc74\u9618\ud811\udd67\u9665\u9d74\ud80c\udc65\ud80c\ude18\u4c82\u9961\u9a74\ud808\udd6d\ud80c\udc18 Aggregation stage \u00b6 9553935200 E29352013293520302925603 [ ARRAY_FLATTEN , // 0x53, [ ARRAY_FILTER , FILTER_GT , - 30 ], // [ 0x52, 0x00, -30 ], [ ARRAY_FILTER , FILTER_LT , 50 ], // [ 0x52, 0x01, 50 ], [ ARRAY_FILTER , FILTER_DEV_ABS , 2 ], // [ 0x52, 0x03, 2 ], [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Drop every negative Result ( Err items) from the input Array , Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and emit the arithmetic mean of the remaining values in the Array . Tally stage \u00b6 The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. 935393520502925603 [ ARRAY_FLATTEN , // 0x53, [ ARRAY_FILTERFILTER_DEV_STD , 2 ], // [ 0x52, 0x05, 2 ], [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Drop every negative Result ( Err items) from the input Array , Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array . What's the USD price of a bitcoin? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the Coinbase price API that returns the current price of a bitcoin in US dollars. Retrieval stage \u00b6 9843749261 A3627069749261A3555344749261AA726174655F666C6F617472 [ OP_STRING_PARSEJSON , // 0x43, OP_MIXED_TOMAP , // 0x74. [ OP_MAP_GET , \"bpi\" ], // [ 0x61, \"bpi\" ]. OP_MIXED_TOMAP , // 0x74. [ OP_MAP_GET , \"USD\" ], // [ 0x61, \"USD\" ]. OP_MIXED_TOMAP , // 0x74. [ OP_MAP_GET , \"rate_float\" ], // [ 0x61, \"rate_float\" ]. OP_MIXED_TOFLOAT // 0x72 ] Treat the structure as Map<String, Mixed> , Take the value of the \"bpi\" key as Mixed , Treat the structure as Map<String, Mixed> . Take the value of the \"USD\" key as Mixed , Treat the structure as Map<String, Mixed> . Take the value of the \"rate_float\" key as Mixed , Emit the value as Float . Aggregation stage \u00b6 The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. 935393520502925603 [ ARRAY_FLATTEN , // 0x53, [ ARRAY_FILTERFILTER_DEV_STD , 2 ], // [ 0x52, 0x05, 2 ], [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Drop every negative Result ( Err items) from the input Array , Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array . Tally stage \u00b6 For the tally stage we can safely use the same generic script as for the aggregation stage. Heads or tails? \u00b6 The following retrieval, aggregation and tally scripts operate on the result of this query to the Australian National University Quantum Random Numbers Server that returns true random numbers in the [0, 255] range generated in real-time by measuring the quantum fluctuations of the vacuum in a laboratory. The tally stage computes the average of the values reported by multiple witness nodes, which will produce a point in the [0, 255] range that is normally distributed around the half-range, i.e. it will fall in any of the [0, 127] or [128, 255] sub-ranges with a 50% probability. Finally, it checks in which side of the half-range did the point actually fall and maps that into a String with value heads or tails . Retrieval stage \u00b6 9543749261 A46461746170925400 [ OP_STRING_PARSEJSON , // 0x43, OP_MIXED_TOMAP , // 0x74, [ OP_MAP_GET , \"data\" ], // [ 0x61, \"data\" ], OP_MIXED_TOARRAY , // 0x70, [ OP_ARRAY_GET , 0 ] // [ 0x54, 0 ] ] Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map<String, Mixed> , Take the value of the \"data\" key as Mixed , Treat the structure as Array<Mixed> . Take the value at index 0 as Mixed , Emit the value as Float . Aggregation stage \u00b6 9653925292 CC8100925292CC810092560392327F92109292C2A5686561647392C3A57461696C73 [ OP_ARRAY_FLATTEN , // 0x53, [ OP_ARRAY_FILTER , [ FILTER_NOT_LT , 0 ] ], // [ 0x52, [ 0x81, 0 ] ], [ OP_ARRAY_FILTER , [ FILTER_NOT_GT , 255 ] ], // [ 0x52, [ 0x81, 0 ] ], [ OP_ARRAY_REDUCE , REDUCER_AVERAGE_MEAN ], // [ 0x56, 0x03 ], [ OP_FLOAT_GREATER , 127 ], // [ 0x32, 127 ], [ OP_BOOLEAN_MATCH , [ // [ 0x10, [ [ false , \"heads\" ], // [ false, \"heads\" ], [ true , \"tails\" ] // [ true, \"tails\" ] ] ] // ] ] Drop every negative Result ( Err items) from the input Array , Remove any items with value under 0 from the remaining Array , Remove any items with value over 255 from the remaining Array , Calculate the arithmetic mean of the remaining Array , Check if the resulting Float is greater than 127 , and continue with a Boolean of value true or false accordingly, Map the Boolean to String by converting false into \"heads\" and true into \"tails\" .","title":"Examples"},{"location":"protocol/data-requests/examples/#examples","text":"","title":"Examples"},{"location":"protocol/data-requests/examples/#whats-the-weather-in-berlin","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the OpenWeatherMap API that returns the current weather conditions in Berlin.","title":"What's the weather in Berlin?"},{"location":"protocol/data-requests/examples/#retrieval-stage","text":"Javascript const openWeatherMaps = new Source ( \"https://openweathermap.org/data/2.5/weather?id=2950159&appid=b6907d289e10d714a6e88b30761fae22\" ) . asString () // Treat the response as a string of text (retrieval always starts with `Bytes`) . parseJSON () // Parse the string, which we now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"weather\" ) // Get the value associated to the `weather` key . asMap () // Treat that as a Javascript object too . get ( \"temp\" ) // Now get the value associated to the `weather` key . asFloat (); // Finally treat that as a floating point number RADON-AST [ BYTES_ASSTRING , STRING_PARSEJSON , MIXED_ASMAP , [ MAP_GET , \"weather\" ], MIXED_ASMAP , [ MAP_GET , \"temp\" ], MIXED_ASFLOAT ] RADON-JSON [ 117 , 69 , 116 , [ 97 , 'weather' ], 116 , [ 97 , 'temp' ], 114 ] CBOR (Base16) 87187518451874821861677765617468657218748218616474656 D701872 CBOR (Base64) hxh1GEUYdIIYYWd3ZWF0aGVyGHSCGGFkdGVtcBhy CBOR (Base65536) \u4c87\u4c75\u4c45\ud842\udc74\u9618\ud811\udd67\u9665\u9d74\ud80c\udc65\ud80c\ude18\u4c82\u9961\u9a74\ud808\udd6d\ud80c\udc18","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#aggregation-stage","text":"9553935200 E29352013293520302925603 [ ARRAY_FLATTEN , // 0x53, [ ARRAY_FILTER , FILTER_GT , - 30 ], // [ 0x52, 0x00, -30 ], [ ARRAY_FILTER , FILTER_LT , 50 ], // [ 0x52, 0x01, 50 ], [ ARRAY_FILTER , FILTER_DEV_ABS , 2 ], // [ 0x52, 0x03, 2 ], [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Drop every negative Result ( Err items) from the input Array , Drop values less or equal than -30 , Drop values greater or equal than 50 , Drop values deviating from the average more than 2 , Calculate and emit the arithmetic mean of the remaining values in the Array .","title":"Aggregation stage"},{"location":"protocol/data-requests/examples/#tally-stage","text":"The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. 935393520502925603 [ ARRAY_FLATTEN , // 0x53, [ ARRAY_FILTERFILTER_DEV_STD , 2 ], // [ 0x52, 0x05, 2 ], [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Drop every negative Result ( Err items) from the input Array , Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array .","title":"Tally stage"},{"location":"protocol/data-requests/examples/#whats-the-usd-price-of-a-bitcoin","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the Coinbase price API that returns the current price of a bitcoin in US dollars.","title":"What's the USD price of a bitcoin?"},{"location":"protocol/data-requests/examples/#retrieval-stage_1","text":"9843749261 A3627069749261A3555344749261AA726174655F666C6F617472 [ OP_STRING_PARSEJSON , // 0x43, OP_MIXED_TOMAP , // 0x74. [ OP_MAP_GET , \"bpi\" ], // [ 0x61, \"bpi\" ]. OP_MIXED_TOMAP , // 0x74. [ OP_MAP_GET , \"USD\" ], // [ 0x61, \"USD\" ]. OP_MIXED_TOMAP , // 0x74. [ OP_MAP_GET , \"rate_float\" ], // [ 0x61, \"rate_float\" ]. OP_MIXED_TOFLOAT // 0x72 ] Treat the structure as Map<String, Mixed> , Take the value of the \"bpi\" key as Mixed , Treat the structure as Map<String, Mixed> . Take the value of the \"USD\" key as Mixed , Treat the structure as Map<String, Mixed> . Take the value of the \"rate_float\" key as Mixed , Emit the value as Float .","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#aggregation-stage_1","text":"The following tally script is quite generic but should work for most cases in which we are trying to build consensus on Integer or Float data points. 935393520502925603 [ ARRAY_FLATTEN , // 0x53, [ ARRAY_FILTERFILTER_DEV_STD , 2 ], // [ 0x52, 0x05, 2 ], [ ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Drop every negative Result ( Err items) from the input Array , Drop values deviating from the average more than twice the standard deviation of the remaining values in the Array , Calculate and emit the arithmetic mean of the remaining values in the Array .","title":"Aggregation stage"},{"location":"protocol/data-requests/examples/#tally-stage_1","text":"For the tally stage we can safely use the same generic script as for the aggregation stage.","title":"Tally stage"},{"location":"protocol/data-requests/examples/#heads-or-tails","text":"The following retrieval, aggregation and tally scripts operate on the result of this query to the Australian National University Quantum Random Numbers Server that returns true random numbers in the [0, 255] range generated in real-time by measuring the quantum fluctuations of the vacuum in a laboratory. The tally stage computes the average of the values reported by multiple witness nodes, which will produce a point in the [0, 255] range that is normally distributed around the half-range, i.e. it will fall in any of the [0, 127] or [128, 255] sub-ranges with a 50% probability. Finally, it checks in which side of the half-range did the point actually fall and maps that into a String with value heads or tails .","title":"Heads or tails?"},{"location":"protocol/data-requests/examples/#retrieval-stage_2","text":"9543749261 A46461746170925400 [ OP_STRING_PARSEJSON , // 0x43, OP_MIXED_TOMAP , // 0x74, [ OP_MAP_GET , \"data\" ], // [ 0x61, \"data\" ], OP_MIXED_TOARRAY , // 0x70, [ OP_ARRAY_GET , 0 ] // [ 0x54, 0 ] ] Parse the input String as a JSON document (retrieval always starts with String ), Treat the structure as Map<String, Mixed> , Take the value of the \"data\" key as Mixed , Treat the structure as Array<Mixed> . Take the value at index 0 as Mixed , Emit the value as Float .","title":"Retrieval stage"},{"location":"protocol/data-requests/examples/#aggregation-stage_2","text":"9653925292 CC8100925292CC810092560392327F92109292C2A5686561647392C3A57461696C73 [ OP_ARRAY_FLATTEN , // 0x53, [ OP_ARRAY_FILTER , [ FILTER_NOT_LT , 0 ] ], // [ 0x52, [ 0x81, 0 ] ], [ OP_ARRAY_FILTER , [ FILTER_NOT_GT , 255 ] ], // [ 0x52, [ 0x81, 0 ] ], [ OP_ARRAY_REDUCE , REDUCER_AVERAGE_MEAN ], // [ 0x56, 0x03 ], [ OP_FLOAT_GREATER , 127 ], // [ 0x32, 127 ], [ OP_BOOLEAN_MATCH , [ // [ 0x10, [ [ false , \"heads\" ], // [ false, \"heads\" ], [ true , \"tails\" ] // [ true, \"tails\" ] ] ] // ] ] Drop every negative Result ( Err items) from the input Array , Remove any items with value under 0 from the remaining Array , Remove any items with value over 255 from the remaining Array , Calculate the arithmetic mean of the remaining Array , Check if the resulting Float is greater than 127 , and continue with a Boolean of value true or false accordingly, Map the Boolean to String by converting false into \"heads\" and true into \"tails\" .","title":"Aggregation stage"},{"location":"protocol/data-requests/overview/","text":"Data requests \u00b6 Data requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand. Request life cycle \u00b6 Once a data request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s. For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide. The RAD Engine \u00b6 The RAD Engine is the component in charge of processing data requests coming from Witnet clients. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All data requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Aggregate and Deliver . RAD Object Notation (RADON) \u00b6 The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted. Creating data requests \u00b6 The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can safely write RADON without their heads exploding, they are just not expected to. The Sheikah desktop app is intended to be used as an IDE for visually and safely composing and testing Witnet data requests. It is also to be expected that at some point in the future, higher-level programming languages may exist for writing data requests in a more expressive and user-friendly way.","title":"Overview"},{"location":"protocol/data-requests/overview/#data-requests","text":"Data requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand.","title":"Data requests"},{"location":"protocol/data-requests/overview/#request-life-cycle","text":"Once a data request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s. For more information on data types, you can read the RADON documentation , which provides a detailed description of all the types and the operators they provide.","title":"Request life cycle"},{"location":"protocol/data-requests/overview/#the-rad-engine","text":"The RAD Engine is the component in charge of processing data requests coming from Witnet clients. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All data requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Aggregate and Deliver .","title":"The RAD Engine"},{"location":"protocol/data-requests/overview/#rad-object-notation-radon","text":"The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted.","title":"RAD Object Notation (RADON)"},{"location":"protocol/data-requests/overview/#creating-data-requests","text":"The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can safely write RADON without their heads exploding, they are just not expected to. The Sheikah desktop app is intended to be used as an IDE for visually and safely composing and testing Witnet data requests. It is also to be expected that at some point in the future, higher-level programming languages may exist for writing data requests in a more expressive and user-friendly way.","title":"Creating data requests"},{"location":"protocol/data-requests/radon-encoding/","text":"RADON encoding \u00b6 RADON scripts are encoded using MessagePack , a very efficient, compact and widely supported data structure encoding. Look for example at this impressively short (22 bytes) serialized RADON script: // As bytes 96 43 74 92 61 A7 77 65 61 74 68 65 72 74 92 61 A4 74 65 6 D 70 72 // As Base64 string \"lkN0kmGnd2VhdGhlcnSSYaR0ZW1wcg==\" Once decoded, the resulting structure will actually represent this RADON script: [ STRING_PARSEJSON , // 0x43 MIXED_TOMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_TOMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_TOFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences but at the same time represent high-level abstractions. In an hypothetical Javascript-like representation of RADON operators, the script above may resemble: retrieve ( url ) . parseJSON () . toMap () . get ( \"weather\" ) . toMap () . get ( \"temp\" ) . toFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"Encoding"},{"location":"protocol/data-requests/radon-encoding/#radon-encoding","text":"RADON scripts are encoded using MessagePack , a very efficient, compact and widely supported data structure encoding. Look for example at this impressively short (22 bytes) serialized RADON script: // As bytes 96 43 74 92 61 A7 77 65 61 74 68 65 72 74 92 61 A4 74 65 6 D 70 72 // As Base64 string \"lkN0kmGnd2VhdGhlcnSSYaR0ZW1wcg==\" Once decoded, the resulting structure will actually represent this RADON script: [ STRING_PARSEJSON , // 0x43 MIXED_TOMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_TOMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_TOFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences but at the same time represent high-level abstractions. In an hypothetical Javascript-like representation of RADON operators, the script above may resemble: retrieve ( url ) . parseJSON () . toMap () . get ( \"weather\" ) . toMap () . get ( \"temp\" ) . toFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"RADON encoding"},{"location":"try/my-first-data-request/","text":"Create a Data Request \u00b6 Witnet data requests can be easily created with the witnet-request Javascript library. If you know some Javascript, you have already done the hardest part! Create a new Witnet-enabled Node project \u00b6 When creating a new project from scratch, the quickest way to get things working is using Truffle to import a Witnet-enabled project template: truffle unbox witnet/truffle-box If you prefer not to use Truffle, you are OK to go with plain npm or yarn : npm mkdir my-first-witnet-project cd my-first-witnet-project npm init npm install --save witnet-request yarn mkdir my-first-witnet-project cd my-first-witnet-project yarn init yarn add witnet-request Add witnet-request to your existing Node project \u00b6 If you want to build support for Witnet into your existing project, you can simply add the witnet-request contract as a dependency: npm npm install --save witnet-request yarn yarn add witnet-request Write your first Witnet request \u00b6 In this example we will: Query two different APIs for the USD price of a bitcoin using 4 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be consumed by a smart contract. Ok, time to get down to work . First off, create a BitcoinPrice.js file where you will write the request. You can place it anywhere, but it is recommended to put all the request files inside your project in a single directory called requests . Tip If you are using the Truffle template, you already have a requests folder in your project. That is totally the right place to create the BitcoinPrice.js file. Import the library \u00b6 Importing the witnet-request library into your BitcoinPrice.js request is pretty straightforward: import * as Witnet from \"witnet-request\" Define the data sources \u00b6 Data sources are each of the endpoints from which you want the witnessing nodes to retrieve the data. Most times, these will be the URLs of public APIs. The number of sources in a single data request is unlimited\u2060\u2014although the more sources, the higher the fees. Each source can have a companion script that lists operations that we want the witnesses to apply on the retrieved data. This enables you to extract the information of your interest out of larger data structures like JSON objects. The scripting language in data request is quite rich indeed: in addition to selecting specific pieces of data, you can also transform those so they are uniform and can be compared or aggregated together. E.g. imagine a weather forecast data request. One source may use Celsius and the other may use Fahrenheit, but you will tell the witnesses to transform one into another so they can be averaged. In this tutorial, you will be defining two data sources: Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . asString () // Treat the response as a string of text . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . asString () // Treat the response as a string of text . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `last` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `last` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number These scripts are quite self-explanatory, but there are a few details that are worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator. Source scripts always start with a binary stream of bytes 1 , hence the need for the .asString () operator. Type conversions are explicit, i.e. you need to use .asString () , .asMap () , .asFloat () , etc. Key-value data structures (alike to Javascript objects) are called maps . Values in maps cannot be accessed directly by name as .keyName but rather accessed through a call to the .get ( \"keyName\" ) operator. The final return type of a script is that of its last operator. All source scripts should return exactly the same type ( Float in this case). Define the aggregator script \u00b6 Good . Now it is time for defining how you want the witnesses to reduce the results of the different sources into the single data point that they will report. Every data request needs exactly one aggregator script, which can be written using the same syntax, types and operators as source scripts and just any other kind of Witnet scripts. Here goes your aggregator script: const aggregator = new Witnet . Aggregator ([ coindesk , bitstamp ]) . flatten () . filter ( Witnet . Filters . deviationStandard , 2 ) . reduce ( Witnet . Reducers . averageMean ) This may look simpler than the source scripts, but there are some details that deserve some special attention: When creating aggregator scripts you need to specify the sources on which it will be applied ( [bitstamp, coindesk] in the example) so the compiler knows the input type and can check for uniformity. All aggregator scripts start with an Array containing as many items as sources, where those items can be Result::Ok(value) or Result::Err(errorMessage) : [ Result :: Ok ( 10284 ), Result :: Ok ( 10291 ) ] // Both sources succeeded [ Result :: Ok ( 10284 ), Result :: Err ( \"404: Not Found\" ) ] // The second source failed The .flatten () operator removes all Result::Err(errorMessage) items, i.e. it gets rid of any source that failed to respond, responded with an error code or whose companion script failed to execute. You can filter the remaining source responses using any of the available filters. The one you are using here is specially powerful, as it removes any data point that falls twice as far from the average as the standard deviation of the entire Array . Clever, huh? Finally, you are telling the witnesses to calculate the arithmetic mean of the remaining data points and report the result so that the request can move on to the final stage of the request: the tally. Define the tally script \u00b6 This far you have created a couple of data sources and then an aggregator script that reduces them down to a single data point. But the fun does not end here. You actually want several nodes to perform the retrieval and aggregation separately. Guess how can you specify how to reduce their respective results into the single data point that your smart contract will be expecting? Ok, you saw it coming : with another script. Tally scripts are very much alike to aggregator scripts, being the main difference that they operate on the results coming from different nodes instead of different data sources. Once again, tally scripts are written using the same syntax and types as source and aggregator scripts, however, a few operators are disabled for security reasons 2 . Tip One another point you should have in mind is that any witness node whose reported result is discarded by the filters in the tally script will receive no rewards. In other words, only those nodes whose results pass all the filters will be taken into account during rewards distribution. Here goes your tally script: const tally = new Tally ( aggregator ) . flatten () . filter ( Witnet . Filters . deviationStandard , 1.5 ) . reduce ( Witnet . Filters . averageMean ) As you can see, tally scripts tend to be quite similar to aggregator scripts. In this case, the only two differences are: The aggregator script needs to be passed to the Tally constructor it knows what is the input type. The harshness of the deviation filter has been fine tuned (from 2 to 1.5 ) to produce a higher-quality result as more outliers will be left out of the final value\u2014and out of the rewards distribution too. Put everything together \u00b6 You have already created every single piece that make up a data request. You are almost there! Now it is time to put them all together and set some final parameters: const request = new Request () // Create a new request . addSource ( bitstamp ) // Adds Bitstamp as a source . addSource ( coindesk ) // Adds CoinDesk as a source . setAggregator ( aggregator ) // Set aggregation function . setTally ( tally ) // Set tally function . setWitnessCount ( 4 , 2 ) // Require between 4 and 6 witnessing nodes . schedule ( 1669852800 ) // Schedule for a specific date in the future export { request as default } // IMPORTANT: export the request as an ES6 module Next steps \u00b6 At this point, you have a Javascript module that when imported into your own projects will produce a valid Witnet data request containing the RADON scripts that Witnet nodes can parse and execute. But how can you actually send the request to the network and have it resolved by a randomly selected sample of Witnet nodes? From here, you have a couple of options: Send the data request from an Ethereum smart contract and have the result resolve the outcome of the contract . Post the data request directly into Witnet just for the sake of attesting the data point without triggering any onchain consequence. The Witnet protocol makes no assumptions on what the data type of the response will be for different data sources. This allows dealing with formats other than plain text, such as multimedia files and any other kind of binaries. Thus, source scripts always start with Bytes as the input type and it is totally up to the requester to specify whether those bytes should be interpreted as a String , Integer or whatnot. \u21a9 Using operators like Array::get() , Array::sort() and Array::take() as well as the minimum and maximum reducer functions in a consensus script makes the result of the request too easily influenced by each individual witness node and can therefore introduce spurious incentives to tamper with request so as to maximize their own profit at the expense of data integrity. \u21a9","title":"Create a Data Request"},{"location":"try/my-first-data-request/#create-a-data-request","text":"Witnet data requests can be easily created with the witnet-request Javascript library. If you know some Javascript, you have already done the hardest part!","title":"Create a Data Request"},{"location":"try/my-first-data-request/#create-a-new-witnet-enabled-node-project","text":"When creating a new project from scratch, the quickest way to get things working is using Truffle to import a Witnet-enabled project template: truffle unbox witnet/truffle-box If you prefer not to use Truffle, you are OK to go with plain npm or yarn : npm mkdir my-first-witnet-project cd my-first-witnet-project npm init npm install --save witnet-request yarn mkdir my-first-witnet-project cd my-first-witnet-project yarn init yarn add witnet-request","title":"Create a new Witnet-enabled Node project"},{"location":"try/my-first-data-request/#add-witnet-request-to-your-existing-node-project","text":"If you want to build support for Witnet into your existing project, you can simply add the witnet-request contract as a dependency: npm npm install --save witnet-request yarn yarn add witnet-request","title":"Add witnet-request to your existing Node project"},{"location":"try/my-first-data-request/#write-your-first-witnet-request","text":"In this example we will: Query two different APIs for the USD price of a bitcoin using 4 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be consumed by a smart contract. Ok, time to get down to work . First off, create a BitcoinPrice.js file where you will write the request. You can place it anywhere, but it is recommended to put all the request files inside your project in a single directory called requests . Tip If you are using the Truffle template, you already have a requests folder in your project. That is totally the right place to create the BitcoinPrice.js file.","title":"Write your first Witnet request"},{"location":"try/my-first-data-request/#import-the-library","text":"Importing the witnet-request library into your BitcoinPrice.js request is pretty straightforward: import * as Witnet from \"witnet-request\"","title":"Import the library"},{"location":"try/my-first-data-request/#define-the-data-sources","text":"Data sources are each of the endpoints from which you want the witnessing nodes to retrieve the data. Most times, these will be the URLs of public APIs. The number of sources in a single data request is unlimited\u2060\u2014although the more sources, the higher the fees. Each source can have a companion script that lists operations that we want the witnesses to apply on the retrieved data. This enables you to extract the information of your interest out of larger data structures like JSON objects. The scripting language in data request is quite rich indeed: in addition to selecting specific pieces of data, you can also transform those so they are uniform and can be compared or aggregated together. E.g. imagine a weather forecast data request. One source may use Celsius and the other may use Fahrenheit, but you will tell the witnesses to transform one into another so they can be averaged. In this tutorial, you will be defining two data sources: Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . asString () // Treat the response as a string of text . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"last\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . asString () // Treat the response as a string of text . parseJSON () // Parse the string, which you now to be JSON-encoded . asMap () // Treat that as a Javascript object . get ( \"bpi\" ) // Get the value associated to the `last` key . asMap () // Treat that as a Javascript object . get ( \"USD\" ) // Get the value associated to the `last` key . asMap () // Treat that as a Javascript object . get ( \"rate_float\" ) // Get the value associated to the `last` key . asFloat () // Treat that as a floating point number These scripts are quite self-explanatory, but there are a few details that are worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator. Source scripts always start with a binary stream of bytes 1 , hence the need for the .asString () operator. Type conversions are explicit, i.e. you need to use .asString () , .asMap () , .asFloat () , etc. Key-value data structures (alike to Javascript objects) are called maps . Values in maps cannot be accessed directly by name as .keyName but rather accessed through a call to the .get ( \"keyName\" ) operator. The final return type of a script is that of its last operator. All source scripts should return exactly the same type ( Float in this case).","title":"Define the data sources"},{"location":"try/my-first-data-request/#define-the-aggregator-script","text":"Good . Now it is time for defining how you want the witnesses to reduce the results of the different sources into the single data point that they will report. Every data request needs exactly one aggregator script, which can be written using the same syntax, types and operators as source scripts and just any other kind of Witnet scripts. Here goes your aggregator script: const aggregator = new Witnet . Aggregator ([ coindesk , bitstamp ]) . flatten () . filter ( Witnet . Filters . deviationStandard , 2 ) . reduce ( Witnet . Reducers . averageMean ) This may look simpler than the source scripts, but there are some details that deserve some special attention: When creating aggregator scripts you need to specify the sources on which it will be applied ( [bitstamp, coindesk] in the example) so the compiler knows the input type and can check for uniformity. All aggregator scripts start with an Array containing as many items as sources, where those items can be Result::Ok(value) or Result::Err(errorMessage) : [ Result :: Ok ( 10284 ), Result :: Ok ( 10291 ) ] // Both sources succeeded [ Result :: Ok ( 10284 ), Result :: Err ( \"404: Not Found\" ) ] // The second source failed The .flatten () operator removes all Result::Err(errorMessage) items, i.e. it gets rid of any source that failed to respond, responded with an error code or whose companion script failed to execute. You can filter the remaining source responses using any of the available filters. The one you are using here is specially powerful, as it removes any data point that falls twice as far from the average as the standard deviation of the entire Array . Clever, huh? Finally, you are telling the witnesses to calculate the arithmetic mean of the remaining data points and report the result so that the request can move on to the final stage of the request: the tally.","title":"Define the aggregator script"},{"location":"try/my-first-data-request/#define-the-tally-script","text":"This far you have created a couple of data sources and then an aggregator script that reduces them down to a single data point. But the fun does not end here. You actually want several nodes to perform the retrieval and aggregation separately. Guess how can you specify how to reduce their respective results into the single data point that your smart contract will be expecting? Ok, you saw it coming : with another script. Tally scripts are very much alike to aggregator scripts, being the main difference that they operate on the results coming from different nodes instead of different data sources. Once again, tally scripts are written using the same syntax and types as source and aggregator scripts, however, a few operators are disabled for security reasons 2 . Tip One another point you should have in mind is that any witness node whose reported result is discarded by the filters in the tally script will receive no rewards. In other words, only those nodes whose results pass all the filters will be taken into account during rewards distribution. Here goes your tally script: const tally = new Tally ( aggregator ) . flatten () . filter ( Witnet . Filters . deviationStandard , 1.5 ) . reduce ( Witnet . Filters . averageMean ) As you can see, tally scripts tend to be quite similar to aggregator scripts. In this case, the only two differences are: The aggregator script needs to be passed to the Tally constructor it knows what is the input type. The harshness of the deviation filter has been fine tuned (from 2 to 1.5 ) to produce a higher-quality result as more outliers will be left out of the final value\u2014and out of the rewards distribution too.","title":"Define the tally script"},{"location":"try/my-first-data-request/#put-everything-together","text":"You have already created every single piece that make up a data request. You are almost there! Now it is time to put them all together and set some final parameters: const request = new Request () // Create a new request . addSource ( bitstamp ) // Adds Bitstamp as a source . addSource ( coindesk ) // Adds CoinDesk as a source . setAggregator ( aggregator ) // Set aggregation function . setTally ( tally ) // Set tally function . setWitnessCount ( 4 , 2 ) // Require between 4 and 6 witnessing nodes . schedule ( 1669852800 ) // Schedule for a specific date in the future export { request as default } // IMPORTANT: export the request as an ES6 module","title":"Put everything together"},{"location":"try/my-first-data-request/#next-steps","text":"At this point, you have a Javascript module that when imported into your own projects will produce a valid Witnet data request containing the RADON scripts that Witnet nodes can parse and execute. But how can you actually send the request to the network and have it resolved by a randomly selected sample of Witnet nodes? From here, you have a couple of options: Send the data request from an Ethereum smart contract and have the result resolve the outcome of the contract . Post the data request directly into Witnet just for the sake of attesting the data point without triggering any onchain consequence. The Witnet protocol makes no assumptions on what the data type of the response will be for different data sources. This allows dealing with formats other than plain text, such as multimedia files and any other kind of binaries. Thus, source scripts always start with Bytes as the input type and it is totally up to the requester to specify whether those bytes should be interpreted as a String , Integer or whatnot. \u21a9 Using operators like Array::get() , Array::sort() and Array::take() as well as the minimum and maximum reducer functions in a consensus script makes the result of the request too easily influenced by each individual witness node and can therefore introduce spurious incentives to tamper with request so as to maximize their own profit at the expense of data integrity. \u21a9","title":"Next steps"},{"location":"try/run-a-node/","text":"Running a Node in the Witnet Testnet \u00b6 The Witnet testnet is open for anyone to join and test it by running their own full node. Running a node on the Witnet mainnet is not possible before the mainnet is released. Check out the roadmap and save the dates! Tip You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to use Witnet from Solidity . Using Docker \u00b6 The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. This docker image downloads and runs a witnet-rust node in the latest testnet in just a matter on seconds. If that's exactly what you want, you can just run this and enjoy: docker run -it witnet/witnet-rust latest node server How to enable persistence \u00b6 Be careful though, as running the image without mounting any volumes may cause total loss of data (including private keys and thus any mined wits). Luckily, enabling persistence is super easy: docker run \\ -v ~/.witnet-rust-testnet-3:/.witnet-rust-testnet-3 \\ -it witnet/witnet-rust latest node server How to run specific releases \u00b6 Specific versions or releases can be simply run form the the same image: docker run \\ -v ~/.witnet-rust-testnet-3:/.witnet-rust-testnet-3 \\ -it witnet/witnet-rust 0 .3.2 node server How to execute CLI commands on the running node \u00b6 First you need to get the CONTAINER ID or NAME of the running node with: docker ps Then, you can run CLI commands on the running node with this simple one-liner. In this example, it will show the latest blocks in the chain: docker exec -i <container_id> ./witnet node blockchain Debug mode \u00b6 Debug mode shows more info on what is happening under the hood. It is activated with the --debug flag in the right place: docker run -it witnet/witnet-rust latest --debug node server Passing the RUST_LOG=witnet=debug environment flag does the same: docker run \\ -e RUST_LOG = witnet = debug \\ -it witnet/witnet-rust latest node server","title":"Run a Node"},{"location":"try/run-a-node/#running-a-node-in-the-witnet-testnet","text":"The Witnet testnet is open for anyone to join and test it by running their own full node. Running a node on the Witnet mainnet is not possible before the mainnet is released. Check out the roadmap and save the dates! Tip You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to use Witnet from Solidity .","title":"Running a Node in the Witnet Testnet"},{"location":"try/run-a-node/#using-docker","text":"The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. This docker image downloads and runs a witnet-rust node in the latest testnet in just a matter on seconds. If that's exactly what you want, you can just run this and enjoy: docker run -it witnet/witnet-rust latest node server","title":"Using Docker"},{"location":"try/run-a-node/#how-to-enable-persistence","text":"Be careful though, as running the image without mounting any volumes may cause total loss of data (including private keys and thus any mined wits). Luckily, enabling persistence is super easy: docker run \\ -v ~/.witnet-rust-testnet-3:/.witnet-rust-testnet-3 \\ -it witnet/witnet-rust latest node server","title":"How to enable persistence"},{"location":"try/run-a-node/#how-to-run-specific-releases","text":"Specific versions or releases can be simply run form the the same image: docker run \\ -v ~/.witnet-rust-testnet-3:/.witnet-rust-testnet-3 \\ -it witnet/witnet-rust 0 .3.2 node server","title":"How to run specific releases"},{"location":"try/run-a-node/#how-to-execute-cli-commands-on-the-running-node","text":"First you need to get the CONTAINER ID or NAME of the running node with: docker ps Then, you can run CLI commands on the running node with this simple one-liner. In this example, it will show the latest blocks in the chain: docker exec -i <container_id> ./witnet node blockchain","title":"How to execute CLI commands on the running node"},{"location":"try/run-a-node/#debug-mode","text":"Debug mode shows more info on what is happening under the hood. It is activated with the --debug flag in the right place: docker run -it witnet/witnet-rust latest --debug node server Passing the RUST_LOG=witnet=debug environment flag does the same: docker run \\ -e RUST_LOG = witnet = debug \\ -it witnet/witnet-rust latest node server","title":"Debug mode"},{"location":"try/use-from-ethereum/","text":"Using Witnet from Ethereum / Solidity \u00b6 Using Witnet as an oracle for resolving your Ethereum smart contracts is really easy thanks to the UsingWitnet Solidity library. Create a new Witnet-enabled project \u00b6 If you are creating a new project from scratch, the quickest way to get things working is using Truffle to import a Witnet-enabled project template: truffle unbox witnet/truffle-box Add Witnet to your existing project \u00b6 If you want to build support for Witnet into your existing Solidity project, you can simply add the UsingWitnet contract as a dependency, which is distributed inside the witnet-ethereum-bridge npm package: npm npm install --save witnet-ethereum-bridge yarn yarn add witnet-ethereum-bridge Write your first Witnet data request \u00b6 We have put together this comprehensive tutorial on how to create a Witnet data request so that you can get started in a matter of minutes. Writing a Solidity contract that uses the Witnet request \u00b6 Once you are done with the tutorial on how to create your first data request , you can directly go back to this section and dive deep into the next step: writing a Solidity contract that deploys a Witnet request, has it resolved and reacts to its result. Let's start from scratch: contract PriceFeed {} Now let's import the UsingWitnet contract and inherit from it: import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" contract PriceFeed is UsingWitnet {} What are we inheriting here? Among other Witnet-related utilities, the UsingWitnet contract injects the following methods into any inheriting contract: postWitnetRequest , which allows you to post an instance of a request to the Witnet Decentralized Oracle Network. readWitnetResult , which allows you to retrieve the result of previously posted requests so that your contract can decide based on its value. Compiling the whole thing \u00b6 Compiling the requests and contracts is as simply as it gets: npm npm run compile yarn yarn compile","title":"Connect your Ethereum contract to an API"},{"location":"try/use-from-ethereum/#using-witnet-from-ethereum-solidity","text":"Using Witnet as an oracle for resolving your Ethereum smart contracts is really easy thanks to the UsingWitnet Solidity library.","title":"Using Witnet from Ethereum / Solidity"},{"location":"try/use-from-ethereum/#create-a-new-witnet-enabled-project","text":"If you are creating a new project from scratch, the quickest way to get things working is using Truffle to import a Witnet-enabled project template: truffle unbox witnet/truffle-box","title":"Create a new Witnet-enabled project"},{"location":"try/use-from-ethereum/#add-witnet-to-your-existing-project","text":"If you want to build support for Witnet into your existing Solidity project, you can simply add the UsingWitnet contract as a dependency, which is distributed inside the witnet-ethereum-bridge npm package: npm npm install --save witnet-ethereum-bridge yarn yarn add witnet-ethereum-bridge","title":"Add Witnet to your existing project"},{"location":"try/use-from-ethereum/#write-your-first-witnet-data-request","text":"We have put together this comprehensive tutorial on how to create a Witnet data request so that you can get started in a matter of minutes.","title":"Write your first Witnet data request"},{"location":"try/use-from-ethereum/#writing-a-solidity-contract-that-uses-the-witnet-request","text":"Once you are done with the tutorial on how to create your first data request , you can directly go back to this section and dive deep into the next step: writing a Solidity contract that deploys a Witnet request, has it resolved and reacts to its result. Let's start from scratch: contract PriceFeed {} Now let's import the UsingWitnet contract and inherit from it: import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" contract PriceFeed is UsingWitnet {} What are we inheriting here? Among other Witnet-related utilities, the UsingWitnet contract injects the following methods into any inheriting contract: postWitnetRequest , which allows you to post an instance of a request to the Witnet Decentralized Oracle Network. readWitnetResult , which allows you to retrieve the result of previously posted requests so that your contract can decide based on its value.","title":"Writing a Solidity contract that uses the Witnet request"},{"location":"try/use-from-ethereum/#compiling-the-whole-thing","text":"Compiling the requests and contracts is as simply as it gets: npm npm run compile yarn yarn compile","title":"Compiling the whole thing"}]}